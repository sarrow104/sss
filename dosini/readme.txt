* sss/dosini/readme

date:2014-04-01

======================================================================

目的：
	不改变顺序 的ini文件读取、生成器

	即，文件重写的时候，会保留换行符、注释等元素。
	或者说，不属于ini语法的元素，都可以选择性保留。

----------------------------------------------------------------------

如何实现？

** 最简单的版本：
	1. 将文件串化；
	2. 对于值的获取，转化为ini字符串的解析，然后获取符合检索要求的部分。
	3. 对于值的更改，转换为ini字符串的解析，定位后，在更改字符串。

	即，该ini配置文件，不保存ini结构；只在需要的时候解析一次（或者说根据改写
	，来解析）

	此时，用一个简单的结构体，来表示内部数据就可以了。

** 复杂的版本
	使用一个负责的文件结构，能够记录变化——并且，对于结构的更改，不会影响其
	他迭代器的使用。

** 中间的版本

	基于行的

	然后，更改只发生在容器尾部。被改掉的，也会被保留。然后新值的行号，被赋值
	给ini结构体。

	然后，用一个顺序的结构，用来记录真正的行顺序。

	这样，基本能保证“游标”在更改后，不会失效。因为赋值变化，只会影响当前行
	号。

----------------------------------------------------------------------
** 如何添加、修改

	添加[块]

	获取[块]列表；块从哪里开始。

	更改的话，如何实现？

----------------------------------------------------------------------

方案1：
	先将ini文件，进行串化——保存在一个std::string 中；然后，分割字符串——
	，在value的地方，将其分割；
	“[block1]”
	"key1="
	"value1"
	分割后的字符串，保存在一个vector中；
	接着，用map对象，保存每一组值，所对应的行号；

	之后，要对value进行修改的话，就修改这个map——而不是更改vector；

----------------------------------------------------------------------

euc 做的 config_file.hpp 还是有借鉴意义的：

利用了C++的 multimap，并使用了互斥体，以提供写保护，等等；

----------------------------------------------------------------------

而，我想的是，编写一个能尽量“容错”的配置文件读取器；所谓的容错，就是允许不符合
语法规则的文字出现，并保留——重写、修改的的时候，也不会丢失；另外，各个块，键值
对的相对顺序，也不会改变；

就是说，所有的更新动作，都会先更新到某个缓存结构体中；然后再将整个结构体写入外存
里面，以完成更新；

即，用户能看到的 enum_block, enum_key，get_value set_value 等，看似无序的操作，
会先顺序更新，到一个顺序结构体——他会记录操作的先后；而不是“键”名字的alpha大
小；

----------------------------------------------------------------------

/*
 * IniFile使用说明
 *
 * 这是读/写Ini配置文件的C++类。
 * 在读取-修改-写入，这样的标准ini文件修改过程中，为了保持原有的ini配置文件的内容顺序；需要记录以下的信息：
 * 行号-类型
 * 类型分为"块"、"注释"、"项"。
 * 在实际的处理上，还有"严格"与"宽松"之分。
 * 所谓，严格，就是：
 * 1. "块"、"注释"、"项"都必须顶格子！
 * 2. "项"必须为"属性","="["值"] 的形式；就是说，只允许"值"可以省略
 * 所谓的，宽松，则没有上述限制——甚至连"块"名也可以省略！
 *
 * "严格"模式如何实现呢？
 *
 * 使用自动机？按行读取？
 * 文件用什么方式打开？文本还是二进制(这关系到如何处理回车符)。
 *
 * TODO finish me!
 */

----------------------------------------------------------------------

时空软件的ini配置文件，有一个特点，它貌似书写不怎么规范，比如键值对前面，竟然有
空格？！

部分行以“//”开头；

而且，更夸张的特性是，如果加密后的密码，不能访问数据库，st_ccerp.exe 还会询问你
正确的密码是多少；如果连接成功，会将密码加密后，更新到ini文件中。而且，该行键值
对的的前导空格信息，还会保留下来！

----------------------------------------------------------------------

怎么说呢，貌似时空的ini配置文件读取模块，有尽量不破坏ini文件人工编写部分的特性。

----------------------------------------------------------------------

我应该如何模仿呢？

----------------------------------------------------------------------
1. 首先，将外存中的ini文件，整个读取到内存中。（mmfile？）

2. 将文件，转换为键值对。并记录块、键、值，的开始、结束byte，或者偏移。

----------------------------------------------------------------------

如果有修改，则额外记录。

于是，块、键、值，这些概念，都可以映射到字符串的整体，或者其中一部分。

甚至，可以记录修改前的值——达到“回退”的效果。

这样，就可以达到存盘后，不修改其他部分的效果。

----------------------------------------------------------------------
伪代码：
	string strfile = io.binfile.load("fname.ini");

	发生更改后，如何写入外存呢？

	我上面的思路，本质上是 缝隙文件 管理。可以用于文件编辑软件的内存管理。

如果没有修改发生，我这个版本的ini文件读写器，就可以扔掉这些内存。

如果有修改——更改键值，或者添加、删除原有的键。

那么……

----------------------------------------------------------------------

如果有了一处修改，那么 缝隙文件，是如何处理的呢？它记录的是连续的内存，以及变化
。

它会如此记录：
	文件原版本=原[0, end]
	文件新版本=原[0, a]+新[0,end]+原[a1, end]
其中：
	原 代表 原始数据的连续存储空间；
	新 代表 新添加的串；
	a,a1分别代表在原始被替换的值的开始与结束处（偏移量）

	文件本身，可以用一个链表来表示——方便插入；
	而内存管理，则可以用；
	vector<string> 来管理；
	其第一条记录，代表原始文件；
	后续的，代表修改处，添加的连续串值。

	然后，链表版本，每一段，保存的不过3个整数：分别是向量的下标，以及字串的
	开始与接受位置——当然，也可以记录，开始位置，和长度。

	总之，用一个三元组即可。

** gap file

有了gap_file之后，又应该如何用来管理dosini的内存呢？

在将外部ini文件，载入到内存之后，需要对其进行解析，找出 块、键值对信息；可以用一
个两层的map结构；来完成；

class dosini : std::map<string, Block>

class Block : std::map<string, gap_file::index>

gap_file::index
	struct
		gap_file * p_gap;
		int source_id;
		int offset;
		int len;

----------------------------------------------------------------------

从简单设并保存
