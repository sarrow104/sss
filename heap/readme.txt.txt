readme.txt
http://bbs.chinaunix.net/thread-4071799-1-1.html

----------------------------------------------------------------------

author:linux_c_py_php
node的内存是用户管理的, heap只释放自己的指针数组, 这是我们项目里需求决定的.

 left越界是与heap->heap_length比较的.

----------------------------------------------------------------------
author:shang2010
加菲猫也是猫
date:2013-03-15

 调整一下代码结构吧，把几个函数调用关系疏离一下，干掉一些不必要的adjust调用，直接换底层的up/down
 比如修改节点，直接拿新原节点prio做比较，改小了上up，改大了下down，这样代码结构应该更清晰些

----------------------------------------------------------------------
author:linux_c_py_php
date:2013-03-15
1, 代码结构不会对程序性能造成数量级10倍的影响, 我是操作libev里堆的接口命名和设计的, 没什么致命伤, 因为算法复杂度摆在这里, 我没有违背. @shang2010
 2, 误会, 我发现你跑的是5000万. 快在哪里. @windoze

 多一层函数调用， 多几次赋值就能慢出10倍去 是不可能的， 我测试了， upheap的交换次数期望为1-2， downheap的交换次数期望大约是upheap的20倍。

----------------------------------------------------------------------
连续内存cache率高?
如果真是连续内存引起的, 那我也没办法了啊, 我要求能够删除node的, 因为定时器可以设置可以删除啊, 用户必须拥有一个独立的node维持其node的索引.

----------------------------------------------------------------------
author:windoze
date:2013-03-15

插入时的siftup和删除时的siftdown的交换次数应该基本相同，你自己想想过程就知道了。
 我的程序快点也许有这么几个原因：
 1、用std::vector存放节点，内存是连续的，cache命中率会明显提高。
 2、heaper是个template，大量操作会被编译器inline，因为这些调用次数极多，所以消除掉函数调用的开销可以显著提高性能。
 3、我直接用void *作为value，你那个好像是个结构体（虽然没仔细看为什么），对这两个类型的操作复杂度应该差不少。

 我之前好像提到过，对于数据结构和算法密集型的程序，C++整体上会有些许性能优势，可惜木有人相信……

----------------------------------------------------------------------
author:linux_c_py_php
date:2013-03-15
我为了让用户可以随时删除堆中node, 所以node是让用户传入的, 这样我就可以在挪动node时候维护其索引, 用户再次传入node的时候我可以根据其index找到并删除.

 想不明白, 我打印log次数的确不同, 不是什么bug吧, 我给你的加上log看看.

----------------------------------------------------------------------

author:windoze
date:2013-03-16

让用户可以操作node并不代表需要让用户管理node的内存，你自己统一管理会比较好。
 如果你需要让用户管理每个node关联的数据，可以在node里加一个指针指向用户数据，这样node依然可以自己管理，比如:
struct node {
    // ...
    void *userdata;
};

struct node *add_node(..., void *userdata) {
    struct node *p=find_next_usable_node(...);
    insert_node_into_heap(..., node);
    p->userdata=userdata;
    return p;
}

void *delete_node(..., struct node *node) {
    void *ret=node->userdata;
    node->userdata=NULL;
    remove_node_from_heap(..., node);
    return ret;
}

----------------------------------------------------------------------
author:freshxman
date:2013-03-16
可能是realloc的问题，我遇到过，你改成memcpy试试

----------------------------------------------------------------------

author:linux_c_py_php
date:2013-03-16

是的, 这就是一个设计问题, node的生命期是谁来看管, 很明显你这种方式会有实践方面的问题, 你可以设想一下用你这种接口实现定时器, 用户会多么困惑, 比如:

 1, 用户添加了一个定时器, 返回给用户一个node.
 2, 你调整堆, 然后用户那个Node已经不是先前的node了, 然后呢? 用户想remove或者modify都不行了.

     我这种用户指定node内存的设计方式有好处, 也有坏处, 但我觉得灵活性方面好处大于坏处, 因为我们xmpp项目里都会用这个方式做定时器, 使用过程:
     1, 用户mio_start(node)插入堆中一个定时器node.
     2, epoll前做堆超时检测, 不断的pop, 然后执行node里的callback, 用户自己就知道定时器node过期了, 这是非常自然的事情.
     3, 在超时之前, 如果用户希望关闭node的定时, 那么自行调用remove就可, 其生命期还是用户掌控的, 仍然非常自然.

----------------------------------------------------------------------
插入过程是realloc慢是必须的, 但现在是删除花费了莫名的30秒.

----------------------------------------------------------------------
author:hbmhalley
date:2013-03-16
  别折腾了，应该不是你的问题
     打印了一下up和down分别的总循环次数与最大循环次数：
         up : 12814222 , down : 206416307 , maxup : 23 , maxdown : 23

     其实很好理解，up的时候插入的是随机数，down的时候基本上离最大数不远，当然调整次数要远超up

----------------------------------------------------------------------
author:linux_c_py_php
date:2013-03-16

windoze 发表于 2013-03-16 00:41
 回复 31# linux_c_py_php

 让用户可以操作node并不代表需要让用户管理node的内存，你自己统一管理会比较 ...


 你的程序有问题吧, 插入的全是0.

----------------------------------------------------------------------

引自csdn算法区的回答:

 差log(n)倍，和理论结果基本一致。
 在我的印象里nlogn的算法当n=100万的时候能1秒搞定已经属于常数很低的了。对于pop 1kw次30秒我觉得非常的正常。

----------------------------------------------------------------------
author:windoze
date:2013-03-16

回复 40# linux_c_py_php

 嗯，测试程序写错了，改改吧：
#include <iostream>
#include <vector>
#include <time.h>
#include <stdlib.h>
#include "heaper.h"

typedef std::vector<size_t> iv;
typedef heaper<iv::iterator> heap_t;
size_t sz=0;

void f1(heap_t &heap) {
    for (size_t i=0; i<sz; ++i) {
        heap.push(i%10000);
    }
}

void f2(heap_t &heap) {
    for (size_t i=0; i<sz; ++i) {
        heap.pop();
    }
}

int main(int argc, const char * argv[])
{
    std::cin >> sz;
    iv v(1000*1000*50,0);
    time_t s=time(NULL);
    heap_t heap=make_heap(v);
    f1(heap);
    f2(heap);
    time_t s1=time(NULL);
    std::cout << s1-s << std::endl;
    return 0;
}

5000万运行时间20秒。

 仔细想了想，删除是会慢一点的，因为每次删除时你都会拿最后的一个替换堆顶，然后siftdown，这个替换上来的元素本来在堆底，所以siftdown很有可能会循环log(n)次，对于5000万总数，约为26次。

 插入时的值是随机的，如果随机数分布均匀，siftup的平均交换次数只有1*(0.5)+2*(0.25)+3*(0.125)... = 2。

 对于n=50000000，这两个数字相差超过10倍。

 你的测试结果没什么问题。
