// FIXME 2015-08-15
// static simpleregex 对象构造函数错误的问题；非法访问！
//#if 1
//    FIXME 不知道怎么回事，常静态的 simpleregex 对象，会导致非法内存访问的错误——试试清理内部用到的流对象？
//    static sss::regex::simpleregex reg_title;
//    static sss::regex::simpleregex reg_cite;
//    static sss::regex::simpleregex reg_ol;
//    static sss::regex::simpleregex reg_ul;
//    static sss::regex::simpleregex reg_bar;
//#else
//    static const sss::regex::simpleregex reg_title;
//    static const sss::regex::simpleregex reg_cite;
//    static const sss::regex::simpleregex reg_ol;
//    static const sss::regex::simpleregex reg_ul;
//    static const sss::regex::simpleregex reg_bar;
//
//#endif
// 特点在于：
// 1. 预读；
// 2. 循环部分通过子函数完成；自增也是；
// 关键在于循环节的判断；
// 之前的，关于缺陷的讨论，焦点在于，循环节的匹配，其本身也是有选路的；
// 就是说，某一个循环节，在该匹配的发生位置，可能有多种匹配路径；但是可能只有一
// 种，能保证整个正则表达式走完。
// 就是说，对于上面的经典模式，该缺陷，也还是存在的；
//
// 即，我需要一个额外的数据结构，由它来重新描述正则表达式——也允许，循环，也允许自我指涉！
//
// 对了，如果用状态机的模式，那么在匹配过程中，当前状态集合（是否匹配、匹配开始
// 位置、结束位置、当前位置），其本身可以作为一个作为状态表的横坐标的！
//----------------------------------------------------------------------
// 那么 DFA有事如何完成的呢？
// 将正则表达式，匹配过程中，times节点对应的匹配次数，作为整体"状态机"的状态的
// 一部分，而生成条件转移表；
//
// DFA的目的，就是避免回溯。
//
// 但是，就我的simpleregex工作的经验来看，光是看被匹配字符串的字符消耗情况，是
// 不足以描述状态的；
// 比如之前我举过的例子：\(ab\)abab$ —— 特点是循环节，就是后续的一部分。
// 总之，消耗一个字符，就意味着正则状态机内部的多种状态；
// 所谓的 DFA，就是将这多个状态，看作一个，进行匹配。
// 那么，如何表示正则表达式的状态呢？该状态需要描述历史吗？
// 如果不需要描述历史，那么需要：
//      1. times 的次数的向量；
//      2. 当前消耗的正则串位置；
//      3. 
//----------------------------------------------------------------------
// 另外，决定之后的匹配是否成功，真的只与剩余字符数量、剩余的正则串序列有关！—
// —以前面的选路情况为变量来看。
// 即，我之前的困境，真的可以用换路来解决。虽然不是指剩余字节数；
// 或者说，match_branches 函数，会返回一个向量，指的是每种可能的情况所消耗的字节数；
// 然后，上层，再根据情况，进行选路；
// ^\(a\+\)\+aa$
// aaa
// 这样，vim中，该正则表达式，可以匹配 "aaa"；而我的则：
// sss::regex::simpleregex("^\\(a+\\)+aa$").match("aaa") = `0`
// 原因就在于，重复的节点内部的选路，没有与外部挂钩！
//
// 就是说，我当前的递归下降策略，完全失败了。修改的话，可能性呢？
//
// 就是说，match_branches，返回一个set，里面是各种可能方式的，消耗字节数……
// 于是，第一次 a+ 部分，返回 {1,2,3}；然后针对余下的 aa$，那么可用的路径，就塌
// 缩为{1}；
// 于是得到一个成功的选择 1,1 （代表，第一个times=1; 第二个times=1）；
// 接着，尝试外部，多匹配一次；2；
// 可能的路径是 {1,2}；但是，对于余下的aa$，都没法匹配成功；于是，第二次尝试，失败。
//
// 就是说，如果我真要保留现在的程序结构，我必须要修改 match_branches 的工作方式！
// 首先，内部的匹配，虽然是贪婪搜索，但是，每一种可能的路径，我都要枚举出来……
// 就是说，match_here 等函数的行为，我也需要修改——只要找出一种可能，就要添加
// 到列表里面（统计剩余被匹配字符串的长度即可）

----------------------------------------------------------------------

分析：
match:
	初始函数；初始化，匹配环境；
	并处理 ^ 或者 移动匹配（起始位置不定）；
	if tok_beg->is_type(START_MATCH)
		match_here()

match_here
	实际的工作分支处理函数；

	mask_part  serial_number
	000321     00001

非法、默认类型
                NULL_MATCH = 0,

消耗字数不定
                REFER_MATCH,    // 0 | 0x0100 "\\[1-9][0-9]"

多次匹配用
                TIMES_MATCH,    // 0 | 0x0200 "\\{min,max}"
                QUESTION_MATCH  // 1 | 0x0200 "\\?" 0 or 1 times
                STAR_MATCH,     // 2 | 0x0200 "*" any; inlude 0
                PLUS_MATCH,     // 3 | 0x0200 "+" many; at least 1

不消耗字符的关键字符：

                START_MATCH,    // 0 | 0x0400 '^'
                END_MATCH,      // 1 | 0x0400 '$'
                WORD_L_MATCH,   // 2 | 0x0400 "\<"
                WORD_R_MATCH,   // 3 | 0x0400 "\>"
                BRANCH_MATCH,   // 4 | 0x0400 "\\|" 分支
                ANCHOR_L_MATCH, // 5 | 0x0400 "\(" 左锚点
                ANCHOR_R_MATCH, // 6 | 0x0400 "\)" 右锚点

消耗单个字符：
                CHAR_MATCH,     // 0 | 0x0800 某单个字符
                DIGIT_MATCH,    // 1 | 0x0800 "\d"
                ALPHA_MATCH,    // 2 | 0x0800 "\c" -- means charachter
                ALNUM_MATCH,    // 3 | 0x0800 "\w" | "\d"
                SPACE_MATCH,    // 4 | 0x0800 "\s"
                NOTSPACE_MATCH, // 5 | 0x0800 "\S"
                SET_MATCH,      // 6 | 0x0800 [abc]        -- 暂时不支持-？
                SET_VERSE_MATCH,// 7 | 0x0800 [^abc]
                ANY_MATCH,      // 8 | 0x0800 .

----------------------------------------------------------------------

学院派的正则表达式，本质上用的是自动机-状态跳转表；

不过，用的是机械化自动编译生成；

由于字符集的庞大（比如int32_t），导致直接在内存中存储跳转表，变得不显示。特别是
正则表达式使用频繁的情况。会导致内存使用激增。

——如果，真要多次使用，最好将其结果对象，与正则表达式对象本身，隔离开来。

陈梓瀚 在 《构造正则表达式引擎》中，提到，将具体的某个正则表达式，它所需要用到的
字符，分类保存；然后找出所有分类（保证分类中，字符是连续的）的划分方法中，数量最
小的一种。

我的想法和作者一样，使用线段树来作为数据结构；

但是，线段树，应该如何生成呢？

首先，在解析正则串的时候，先把用到部分，拆分成连续的区域：

比如‘a’，就生成 [‘a’,‘a’];
【ab】，就生成

----------------------------------------------------------------------

假设，原始的，每个“接受”，都用连续集合 An来标示；分别是 A_1, A_2,...,A_n；

然后，目的是构造一个Bn；分别是 B_1, B_2,...,B_n；

使得，任意的i,j，有A_i 与 B_j 的交际，等于 B_j 或者空集；
并且，在所有可能的组合中，B所划分的区域（子集合元素），数目最少；

----------------------------------------------------------------------

另外，也不是说，simpleregex 就走到头了，就被回溯逼得没法了；

鉴于分支内部选路的问题，必须提供一个让其能够与外界沟通，以便匹配一次后续的能力；

另外，此时的匹配后续部分，只是为了检验是否能走通，所以没有必要完成 贪婪、非贪婪
的区别——即，我得再提供一个状态变量，用来判断当前是否处于“比较后续”模式；

如果处于该模式，那么，一切 TIMES_MATCH 循环，都是非贪婪！只有匹配不成功，才往后
循环；

至于分支，也能处理；比如，在处理分支的时候，可以给出一个统计信息，即，当前选路（
以及分支内部的选录），所耗用的字符数，是否能让后续部分，完成匹配；

这样，再选择其他路径的时候，如果该字节消耗数，已经完成过匹配，那么，后续就不用比
较了。

直到出现了不痛的消耗情况，才尝试做一次“比较后续”的动作；

  std::map<int, bool>
	iterator::first
		当前路径字节消耗数
	iterator::second
		后续部分是否匹配成功？

----------------------------------------------------------------------

该模式，所用的bool 变量，名叫：least_match；即，最少匹配。

----------------------------------------------------------------------
需要一个，剩余 正则串 个数，与未匹配字符串长度、是否能匹配成功的关系的一个数组；

----------------------------------------------------------------------

从使用上，关于后续是否能匹配成功的信息，如果绑定在具体的正则token对象上，那么肯
定会造成困扰——因为就算是同一个token，也意味着有不同的选路状态——比方说，已经
重复了N次；

就是说，这个探查的记录，应该是与被匹配字符串，绑定在一起！它记录着探查过的死路和
活路！还有，剩余的token数！

----------------------------------------------------------------------

我需要做思维实验：
	match_here 中：
	当前节点需要循环处理：
		如果是非引用括号（即，单个token的循环）？
			那么，内部就不可能存在选路：
			只不过，对于外部来说，循环次数，导致有不同的选路；

		如果是引用括号？
			仅有内部只有一条路径，或者所有路径消耗的字节数，都一致，
			就就无所谓预估。相当于只有一条路径——最多是内部的子引用
			的范围不同；

			存在分支或者内部还有 TIMES_MATCH，此时，内部可能有多种选
			路的情况发生；
				如果内部有分支，多半有分支
				如果内部有循环，那么，也可能有分支
					——要不，对字符的匹配消耗情况，做一个预
					估？
					——觉得意义不大，还不如做一个范围预估；

				问题的关键，在于，分支与 TIMES_MATCH 导致的选路
				不同，应该一视同仁！
				我上次，测试浮点数正则表达式的时候，就出现了问题
				：
				浮点数正则表达式，分为三大部分：
				[符号] 数字 [E指数]
				其中，除了数字部分外，其余两部分，都是可以忽略的
				；
				而数字部分，鉴于C/C++语言的怪异特点，小数点，前
				后可以分别省略；
				于是，数字部分的匹配，就有了这样一种分支写法：

					\d+\.?\d*
					\d*\.?\d+

				从逻辑上说，上面两个分支，其实是有重叠部分的！

				我是专门写了一个函数 match_branches 来处理有分支
				的情况；

				该函数的逻辑是，以某分支为正则表达式对象，试着从
				当前位置进行匹配；

				一旦，找到一种匹配模式，另外一个分支，就不再进行
				匹配了。

				这样是不对的：因为，如果当前分支的当前选路（等效
				于每个TIMES_MATCH 重复的次数的集合），通过了匹配
				（子正则表达式匹配成功），但是，回到外面的调用函
				数的时候，再进行后续匹配，也会导致失败！

				这时候，就需要重新进入该分支函数，然后，分支函数
				，根据传入的状态变量，以判断从那里开始，重新选路
				！

				当然，还有一种办法，就是将后续部分的信息，也传递
				给 match_branches 函数，即，让它自己做一次测试，
				以判断当前分支，当前选路规则是否合适；

				不过，此时的问题在于，所谓的“后续部分”，应当如
				何界定？
				当前，遇到分支，有如下几种情况：
				1. 无锚点的外部分支：
					此时，无所谓的后续；

					如何判断是此种情况？可以通过传入的区间，
					与总的区间，相比，得到剩余的区间；
					此时，剩余部分的正则串，长度为0；

				2. 无循环的锚点分支；
					此时，可以用右边界外推1个token，作为后续
					部分的起点；

					此时，本函数可以检测到，有剩余正则串，并
					且第一个是右锚点；更并且，该锚点右侧不是
					TIMES_MATCH token！

				3. 有循环的锚点分支：
					从逻辑上来说，后续部分，等于 当前（循环
					次数标签），对应次数+1（可循环次数-1），
					再加上，token外推1，之后的部分；

					此时，本函数可以检测到，有剩余正则串，并
					且第一个是右锚点；更并且，该锚点右侧正是
					TIMES_MATCH token！

----------------------------------------------------------------------
还是要推翻上面的假设——因为，每一层的路径选择，都与后面部分匹配相关！

即，如果 “a+” 这种正则串，在锚点引用内部的话，那么后续字符串可能就是0个！因为
已经先被括号内部匹配消耗玩了！

于是，整个正则串，提示匹配失败。

就是说，要么我放弃上述方案，要么从一开始，就让正则串处于非贪婪匹配模式！
