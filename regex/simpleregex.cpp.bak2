#include <sss/regex/simpleregex.hpp>

#include <sss/utlstring.hpp>
#include <sss/log.hpp>

#include <sstream>
#include <stdexcept>
#include <map>
#include <set>
#include <list>

#define _MODEL_NAME_ "sss::regex::simpleregex"

namespace sss{
    namespace regex {

        inline bool isword(char ch) // {{{1
        {
            return std::isalpha(ch) || ch == '_';
        }

        inline bool isdigitword(char ch) // {{{1
        {
            return std::isalnum(ch) || ch == '_';
        }

        // 截取串前20字符并返回；超过的话，附上"..."代表未完
        static const char * get_match_type_name(simpleregex::match_type_t t) // {{{1
        {
            static std::map<simpleregex::match_type_t, const char *> names;

            // vim: '<,'>s/^\S\+$/names[simpleregex::\0] = "\0";/ge

            if (names.empty()) {
                names[simpleregex::NULL_MATCH] = "NULL_MATCH";
                names[simpleregex::START_MATCH] = "START_MATCH";
                names[simpleregex::END_MATCH] = "END_MATCH";
                names[simpleregex::WORD_L_MATCH] = "WORD_L_MATCH";
                names[simpleregex::WORD_R_MATCH] = "WORD_R_MATCH";
                names[simpleregex::CHAR_MATCH] = "CHAR_MATCH";
                names[simpleregex::SET_MATCH] = "SET_MATCH";
                names[simpleregex::SET_VERSE_MATCH] = "SET_VERSE_MATCH";
                names[simpleregex::DIGIT_MATCH] = "DIGIT_MATCH";
                names[simpleregex::ALPHA_MATCH] = "ALPHA_MATCH";
                names[simpleregex::ALNUM_MATCH] = "ALNUM_MATCH";
                names[simpleregex::SPACE_MATCH] = "SPACE_MATCH";
                names[simpleregex::NOTSPACE_MATCH] = "NOTSPACE_MATCH";
                names[simpleregex::ANY_MATCH] = "ANY_MATCH";
                names[simpleregex::ANCHOR_L_MATCH] = "ANCHOR_L_MATCH";
                names[simpleregex::ANCHOR_R_MATCH] = "ANCHOR_R_MATCH";
                names[simpleregex::STAR_MATCH] = "STAR_MATCH";
                names[simpleregex::PLUS_MATCH] = "PLUS_MATCH";
                names[simpleregex::REFER_MATCH] = "REFER_MATCH";
                names[simpleregex::BRANCH_MATCH] = "BRANCH_MATCH";
                names[simpleregex::TIMES_MATCH] = "TIMES_MATCH";
                names[simpleregex::QUESTION_MATCH] = "QUESTION_MATCH";
            }
            return names[t];
        }

        simpleregex::match_token::match_token(match_type_t t, const std::string& str, match_case_t m_case) // {{{1
            : type(t), match_case(m_case), anchor_id(0), data(str)
        {
            SSS_LOG_DEBUG("%s %s\n",
                          get_match_type_name(t),
                          data.c_str());
            this->init();
        }

        simpleregex::match_token::match_token(match_type_t t, const std::string& str, int pos, match_case_t m_case) // {{{1
            : type(t), match_case(m_case), anchor_id(pos), data(str)
        {
            SSS_LOG_DEBUG("%s %s %d\n",
                          get_match_type_name(t),
                          data.c_str(),
                          anchor_id);
            this->init();
        }

        bool simpleregex::match_token::init()
        {
            this->sort_with_case();

            // 关于比较次数，以及是否贪婪。
            // vim的做法，与其他的一些正则表达式引擎不同；
            // js里面，
            // + = {1,}
            // * = {}, {0,}
            // ? = {0,1}
            // {n} = {n,n}
            //
            // 此外，? 可以作为次数的后缀，以表示是否开启非贪婪模式。

            // 而 vim 中，没有 ? 后缀模式。而是用 {} 的负号，来表示是否贪婪。
            //
            // \{n,m}	Matches n to m of the preceding atom, as many as possible
            // \{n}	Matches n of the preceding atom
            // \{n,}	Matches at least n of the preceding atom, as many as possible
            // \{,m}	Matches 0 to m of the preceding atom, as many as possible
            // \{}	Matches 0 or more of the preceding atom, as many as possible (like *)
            //
            // \{-n,m}	matches n to m of the preceding atom, as few as possible
            // \{-n}	matches n of the preceding atom
            // \{-n,}	matches at least n of the preceding atom, as few as possible
            // \{-,m}	matches 0 to m of the preceding atom, as few as possible
            // \{-}	matches 0 or more of the preceding atom, as few as possible
            //
            // 就是说，vim 模式，优先使用 \{} 加 - 即可。
            //
            // 这下郁闷了。我还是先实现 vim 模式吧!

            switch (this->type) {
            case TIMES_MATCH:
                {
                    int consume = simpleregex::consume_times_token(data.begin() + 1,
                                                                   data.end(),
                                                                   greed,
                                                                   t_min,
                                                                   t_max);
                    if (!consume) {
                        throw std::invalid_argument("invalid TIMES_MATCH: \"" + data + "\".");
                    }
                }
                break;

            case STAR_MATCH:
                this->greed = true;
                this->t_min = 0;
                this->t_max = -1; // means no limits.
                break;

            case PLUS_MATCH:
                this->greed = true;
                this->t_min = 1;
                this->t_max = -1; // means no limits.
                break;

            case QUESTION_MATCH:
                this->greed = true;
                this->t_min = 0;
                this->t_max = 1; // means no limits.
                break;

            default:
                break;
            }

            return true;
        }

        void simpleregex::match_token::sort_with_case() // {{{1
        {
            // NOTE 本函数的目的在于，构造set\set_inverse集合的时候，先进行排序
            // ？
            if (!this->is_case_sensitive()) {
                std::sort(this->data.begin(), this->data.end(), sss::char_less_casei());
            }
        }

        bool simpleregex::match_token::is_case_sensitive() const // {{{1
        {
            return this->match_case == case_sensitive;
        }

        bool simpleregex::match_token::enable_case_sensitive() // {{{1
        {
            if (this->is_case_sensitive()) {
                return false;
            }
            // case_insensitive -> case_sensitive
            switch (this->type) {
            case SET_MATCH:
            case SET_VERSE_MATCH:
                std::sort(this->data.begin(), this->data.end());
                break;

            default:
                break;
            }
            this->match_case = case_sensitive;
            return true;
        }

        bool simpleregex::match_token::enable_case_insensitive() // {{{1
        {
            if (!this->is_case_sensitive()) {
                return false;
            }

            // case_sensitive -> case_insensitive
            if (this->is_set_type()) {
            }
            switch (this->type) {
            case SET_MATCH:
            case SET_VERSE_MATCH:
                std::sort(this->data.begin(), this->data.end(), sss::char_less_casei());
                break;

            default:
                break;
            }

            this->match_case = case_insensitive;
            return true;
        }

        bool simpleregex::match_token::is_set_type() const // {{{1
        {
            switch (this->type)
            {
            case SET_MATCH:
            case SET_VERSE_MATCH:
                return true;

            default:
                return false;
            }
            return false;
        }

        // TODO
        bool simpleregex::match_token::next(int & times) const
        {
            (void)times;
            return true;
        }

        // TODO
        bool simpleregex::match_token::is_in_range(int times) const
        {
            (void)times;
            return true;
        }

        bool simpleregex::match_token::match(char ch) const // {{{1
        {
            try {
                SSS_LOG_DEBUG("%s [%s : %c] %s\n",
                              get_match_type_name(this->type),
                              this->data.c_str(),
                              ch,
                              this->is_case_sensitive() ? "case_sensitive" : "case_insensitive");
                // NOTE 如何支持忽略大小写的比较？
                // 可以在一开始创建的时候，就体现这种不同。特别是 SET_MATCH
                // ，可以使用大堆；还有 set<std::string> ，传入比较函数。
                // 还有一种办法是使用 vector堆；只不过，在最终find比较的时候
                // ，使用忽略大小写的比较函数（或者对象）
                // 还有，就是 std::set 的 find 插入插入策略。这就限制了变化
                // ……即，simpleregex 在一开始，就要从内部数据上，体现忽略
                // 大小写的不同。
                // 当然，原始数据，还是需要用类set来过滤重复的数据。
                // 不过，就算是vector 模拟的 堆排序即可，在是否忽略大小写的
                // 情况下，顺序还是不同的！
                // 以最大堆为例：
                // std::make_heap(v.begin(), v.end(), std::less)
                // 将生成以根节点为最大值，其左右子树根节点，不大于本根节点
                // 的二叉树。
                // 即，为了体现效率，在切换比较行为时（是否大小写敏感），需
                // 要对各个match成员数据，进行重排。
                // 当然，也可以不管效率，直接用std::find……
                // 另外，排序后，应该用 二分查找 好一点。
                // lower_bound
                // upper_bound
                //
                // 于是，对应是否大小写敏感的修改，将分为两步进行：
                // 1. 修改内部数据结构――set->vector，+ lower_bound or
                // upper_bound
                // 2. 根据属性，来判断大小写敏感。
                //
                // 还有一个办法，可以用空间换时间――即，同时存储两种风格的
                // 内存比较序列。
                // 不过，上述变化真心很少出现……
                if (!this->is_case_sensitive()) {
                    ch = std::toupper(ch);
                }
                switch (this->type) {
                case NULL_MATCH:
                    throw std::invalid_argument("NULL_MATCH token matched!");
                    break;

                case CHAR_MATCH:
                    if (this->is_case_sensitive()) {
                        return this->data[0] == ch;
                    }
                    else {
                        return std::toupper(this->data[0]) == ch;
                    }
                    break;

                case SET_MATCH:
                    if (this->is_case_sensitive()) {
                        return std::binary_search(this->data.begin(), this->data.end(), ch);
                    }
                    else {
                        return std::binary_search(this->data.begin(), this->data.end(), ch, sss::char_less_casei());
                    }
                    break;

                case SET_VERSE_MATCH:
                    if (this->is_case_sensitive()) {
                        return !std::binary_search(this->data.begin(), this->data.end(), ch);
                    }
                    else {
                        return !std::binary_search(this->data.begin(), this->data.end(), ch, sss::char_less_casei());
                    }
                    break;

                case DIGIT_MATCH:
                    if (std::isdigit(ch)) {
                        return true;
                    }
                    break;

                case ALPHA_MATCH:
                    if (isword(ch)) {
                        return true;
                    }
                    break;

                case ALNUM_MATCH:
                    if (isdigitword(ch)) {
                        return true;
                    }
                    break;

                case SPACE_MATCH:
                    if (std::isspace(ch)) {
                        return true;
                    }
                    break;

                case NOTSPACE_MATCH:
                    if (!std::isspace(ch)) {
                        return true;
                    }
                    break;

                case ANY_MATCH:
                    return true;

                default:
                    return false;
                }
                return false;
            }
            catch (std::exception & e) {
                std::cout << __FILE__ << ", " << __LINE__ << std::endl;
                throw;
            }
        }

        simpleregex::simpleregex(const std::string& reg_str, match_case_t _match_case) // {{{1
            : reg_string(reg_str), start_pos(-1), consumed_cnt(0), match_case(_match_case)
        {
            SSS_LOG_DEBUG("(\"%s\", %s)\n", reg_str.c_str(), this->is_case_sensitive() ? "case_sensitive" : "case_insensitive");
            // 这里，应该对 reg_string 进行"分词"
            // 比如，将'^\[sql\d\] --$' 分割为：
            // START_MATCH  "^"
            // CHAR_MATCH   "["
            // CHAR_MATCH   "s"
            // CHAR_MATCH   "q"
            // CHAR_MATCH   "l"
            // DIGIT_MATCH  "\d"
            // CHAR_MATCH   "]"
            // CHAR_MATCH   " "
            // CHAR_MATCH   "-"
            // CHAR_MATCH   "-"
            // END_MATCH    "$"
            //
            // 其他：
            // ALNUM_MATCH "\w"

            std::map<int, int> anchorpairs;

            // NOTE，默认"分支"，针对整个传――可以没有显式的\(\)
            // ――当然，也可以让正则表达式串，默认就用一组\(和\)包裹起来。
            // FIXME 这里应该改为stack结构！
            std::list<int> last_left_anchor;
            last_left_anchor.push_back(-1);

            for (size_t i = 0; i != reg_string.length(); ++i) {
                switch (reg_string[i]) {
                case '^':
                    match_tokens.push_back(match_token(START_MATCH, "^"));
                    break;

                case '$':
                    match_tokens.push_back(match_token(END_MATCH, "$"));
                    break;

                case '*':
                    if (match_tokens.empty() ||
                        match_tokens.back().type == START_MATCH)
                    {
                        throw std::invalid_argument("STAR_MATCH token cannot at first!");
                    }
                    match_tokens.push_back(match_token(STAR_MATCH, "*"));
                    break;

                case '+':
                    if (match_tokens.empty() ||
                        match_tokens.back().type == START_MATCH)
                    {
                        throw std::invalid_argument("PLUS_MATCH token cannot at first!");
                    }
                    match_tokens.push_back(match_token(PLUS_MATCH, "+"));
                    break;

                case '[':       // SET_MATCH or SET_VERSE_MATCH
                    // NOTE 如果需要包含减号'-'，使用"\\-" 即可！
                    {
                        bool is_set_end = false;
                        typedef std::set<char> sub_set_t;
                        sub_set_t sub_set;
                        match_type_t current_type = SET_MATCH;
                        bool is_range = false;
                        char range_beg = '\0';
                        for (size_t j = i + 1; j != reg_string.length(); ++j) {
                            if (j == i + 1 && reg_string[j] == '^') {
                                current_type = SET_VERSE_MATCH;
                            }
                            else if (reg_string[j] == '\\' &&
                                     j + 1 != reg_string.length())
                            {
                                range_beg = reg_string[++j];
                                is_range = false;
                                sub_set.insert(range_beg);
                            }
                            else if (reg_string[j] == ']') {
                                i = j;
                                is_set_end = true;
                                break;
                            }
                            else if (reg_string[j] == '-') {
                                if (range_beg != '\0') {
                                    is_range = true;
                                }
                                else {
                                    throw std::invalid_argument("reg set encouter : [-]");
                                }
                                // FIXME 如果一开始，就是一个'-'；那么……
                            }
                            else {
                                if (is_range) {
                                    char range_end = reg_string[j];
                                    for (char c = range_beg; c <= range_end; ++c) {
                                        sub_set.insert(c);
                                    }
                                    is_range = false;

                                    // 重新取为'\0'；以防止[a-d-k]这种形式！
                                    range_beg = '\0';
                                }
                                else {
                                    range_beg = reg_string[j];
                                    sub_set.insert(reg_string[j]);
                                }
                            }
                        }

                        if (!is_set_end) {
                            throw std::invalid_argument("reg set unmatched \"[\"");
                        }
                        std::string string_set;
                        for (sub_set_t::iterator it = sub_set.begin();
                             it != sub_set.end();
                             ++it)
                        {
                            string_set += *it;
                        }
                        match_tokens.push_back(match_token(current_type, string_set));
                    }
                    break;

                case '\\':
                    {
                        if (i + 1 == reg_string.length()) {
                            throw std::invalid_argument("转义字符不完整");
                        }
                        switch (reg_string[++i]) {
                        case '[':
                            match_tokens.push_back(match_token(CHAR_MATCH, "["));
                            break;

                        case ']':
                            match_tokens.push_back(match_token(CHAR_MATCH, "]"));
                            break;

                        case '^':
                            match_tokens.push_back(match_token(CHAR_MATCH, "^"));
                            break;

                        case '$':
                            match_tokens.push_back(match_token(CHAR_MATCH, "$"));
                            break;

                        case '.': // 2014-08-19 漏了一个 \\. 小数点！
                            match_tokens.push_back(match_token(CHAR_MATCH, "."));
                            break;

                        case '*':
                            match_tokens.push_back(match_token(CHAR_MATCH, "*"));
                            break;

                        case '+':
                            match_tokens.push_back(match_token(CHAR_MATCH, "+"));
                            break;

                        case 's':
                            match_tokens.push_back(match_token(SPACE_MATCH, "\\s"));
                            break;

                        case 'S':
                            match_tokens.push_back(match_token(NOTSPACE_MATCH, "\\S"));
                            break;

                        case 'w':
                            match_tokens.push_back(match_token(ALNUM_MATCH, "\\w"));
                            break;

                        case 'c':
                            match_tokens.push_back(match_token(ALPHA_MATCH, "\\c"));
                            break;

                        case 'd':
                            match_tokens.push_back(match_token(DIGIT_MATCH, "\\d"));
                            break;

                        case '<':
                            match_tokens.push_back(match_token(WORD_L_MATCH, "\\<"));
                            break;

                        case '>':
                            match_tokens.push_back(match_token(WORD_R_MATCH, "\\>"));
                            break;

                        //! 如何进行左右锚点匹配？
                        // NOTE 允许嵌套！但是，不允许未完成的锚点。
                        // 也就是说，是否"合格"的要求，与带括号的运算式相同！
                        // 即，
                        // 1. 左括号，可以随便出现；
                        // 2. 右括号出现的时候，必须在左侧找到空闲的"左括号"
                        // 3. 解析完成的时候，没有孤立(未配对)的括号。
                        case '(':
                            match_tokens.push_back(match_token(ANCHOR_L_MATCH,
                                                               "\\(",
                                                               left_anchors.size()));
                            left_anchors.push_back(0);

                            last_left_anchor.push_back(match_tokens.size() - 1);

                            break;

                        case ')':
                            if (left_anchors.size() <= right_anchors.size()) {
                                throw std::invalid_argument("single right anchor!");
                            }
                            match_tokens.push_back(match_token(ANCHOR_R_MATCH,
                                                               "\\)",
                                                               right_anchors.size()));
                            anchorpairs[last_left_anchor.back()] = match_tokens.size() - 1;

                            //std::cout
                            //    << "sub_match range: "
                            //    << " [" << last_left_anchor.back() << ", " << match_tokens.size() - 1 << "]"
                            //    << std::endl;

                            right_anchors.push_back(0);
                            (void)last_left_anchor.pop_back();

                            break;

                        case '\\':
                            match_tokens.push_back(match_token(CHAR_MATCH, "\\"));
                            break;

                        case '|':
                            match_tokens.push_back(match_token(BRANCH_MATCH, "\\|"));
                            //SSS_LOG_EXPRESSION(sss::log::log_DEBUG, last_left_anchor.back());

                            if (left_anchor2branchs.find(last_left_anchor.back()) == left_anchor2branchs.end()) {
                                // NOTE 分支是一分为二！
                                // 如果有一个分支标记，那么说明是两个分支。
                                // 而一个分支的话，相当于没有分支――即，不用额外处理。
                                left_anchor2branchs[last_left_anchor.back()] = std::vector<int>();
                            }
                            left_anchor2branchs[last_left_anchor.back()].push_back(match_tokens.size() - 1);
                            break;

                        case '{':
                            {
                                bool greed = false;
                                int t_min = 0;
                                int t_max = 0;
                                int consume = this->consume_times_token(reg_string.begin() + i,
                                                                        reg_string.end(),
                                                                        greed,
                                                                        t_min,
                                                                        t_max);
                                if (consume == 0) {
                                    throw std::invalid_argument(std::string("invalid times :\"\\")
                                                                + reg_string.substr(i - 1, 5)+"\"");
                                }

                                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, greed);
                                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, t_min);
                                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, t_max);
                                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, consume);
                                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, reg_string.substr(i - 1, consume + 1));

                                match_tokens.push_back(match_token(TIMES_MATCH, reg_string.substr(i - 1, consume + 1)));
                            }
                            break;

                        case '?':
                            match_tokens.push_back(match_token(QUESTION_MATCH, "\\?"));
                            break;

                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                            {
                                int refer_id = reg_string[i] - '0';
                                if (int(right_anchors.size()) < refer_id) {
                                    throw std::invalid_argument(std::string("invalid reference id :\"\\")
                                                                + reg_string[i]+"\"");
                                }
                                // NOTE 没必要支持多位数……；于是……
                                match_tokens.push_back(match_token(REFER_MATCH,
                                                                   std::string("\\") + reg_string[i],
                                                                   reg_string[i] - '0'));
                            }
                            break;

                        default:
                            throw std::invalid_argument(std::string("unsupport escape string:\"\\")
                                                        + reg_string[i]+"\"");
                        }
                    }
                    break;

                case '.':
                    match_tokens.push_back(match_token(ANY_MATCH, "."));
                    break;

                default:
                    match_tokens.push_back(match_token(CHAR_MATCH,
                                                       std::string(1, reg_string[i])));
                }
            }

            if (left_anchors.size() != right_anchors.size()) {
                throw std::invalid_argument("anchor numbers not balance.");
            }

            if (!this->is_case_sensitive()) {
                this->sort_with_case();
            }

            //for (std::map<int, std::vector<int> >::const_iterator it = left_anchor2branchs.begin();
            //     it != left_anchor2branchs.end();
            //     ++it)
            //{
            //    std::cout << "left_anchor " << it->first << " [";
            //    for (std::vector<int>::const_iterator b_it = it->second.begin();
            //         b_it != it->second.end();
            //         ++b_it)
            //    {
            //        if (b_it != it->second.begin()) {
            //            std::cout << ", ";
            //        }

            //        std::cout << *b_it;
            //    }
            //    std::cout << "]" << std::endl;
            //}

            for (std::map<int, std::vector<int> >::const_iterator it = left_anchor2branchs.begin();
                 it != left_anchor2branchs.end();
                 ++it)
            {
                for (std::vector<int>::const_iterator b_it = it->second.begin();
                     b_it != it->second.end();
                     ++b_it)
                {
                    branch2right_anchor[*b_it] =
                        (it->first == -1 ? match_tokens.size() : anchorpairs[it->first]);
                    //std::cout
                    //    << "(" << *b_it << ", " << branch2right_anchor[*b_it] << ")"
                    //    << std::endl;
                }
            }

            this->tok_beg_bak = this->match_tokens.begin();
        }

        simpleregex::~simpleregex() // {{{1
        {
        }

        bool simpleregex::is_case_sensitive() const // {{{1
        {
            return this->match_case == simpleregex::case_sensitive;
        }

        bool simpleregex::enable_case_sensitive() // {{{1
        {
            if (this->is_case_sensitive()) {
                return false;
            }

            this->sort_with_case();
            this->match_case = case_sensitive;
            //for (match_tokens_t::iterator it = this->match_tokens.begin();
            //     it != this->match_tokens.end();
            //     ++it)
            //{
            //    match_token & match_cur = *it;
            //    match_cur.enable_case_sensitive();
            //}
            return true;
        }

        void simpleregex::sort_with_case() // {{{1
        {
            if (this->is_case_sensitive()) {
                std::for_each(this->match_tokens.begin(),
                              this->match_tokens.end(),
                              std::mem_fun_ref(&simpleregex::match_token::enable_case_sensitive));
            } else {
                std::for_each(this->match_tokens.begin(),
                              this->match_tokens.end(),
                              std::mem_fun_ref(&simpleregex::match_token::enable_case_insensitive));
            }
        }

        bool simpleregex::enable_case_insensitive() // {{{1
        {
            if (!this->is_case_sensitive()) {
                return false;
            }

            this->sort_with_case();

            this->match_case = case_insensitive;
            //for (match_tokens_t::iterator it = this->match_tokens.begin();
            //     it != this->match_tokens.end();
            //     ++it)
            //{
            //    match_token & match_cur = *it;
            //    match_cur.enable_case_insensitive();
            //}
            return true;
        }

        std::string simpleregex::get_submatch(int id) const // {{{1
        {
            if (id == 0) {
                return this->to_match.substr(this->start_pos,
                                             this->consumed_cnt);
            }
            else if (id > 0 && id <= this->get_submatch_count()) {
                int start_pos_ = this->get_submatch_start(id);
                int consumed_cnt_ = this->get_submatch_consumed(id);

                return this->to_match.substr(start_pos_,
                                             consumed_cnt_);
            }
            else {
                return "";
            }
        }

        int         simpleregex::get_submatch_count() const
        {
            return this->left_anchors.size();
        }

        int         simpleregex::get_submatch_start(int id) const
        {
            return this->left_anchors[id - 1];
        }

        int         simpleregex::get_submatch_end(int id) const
        {
            return this->right_anchors[id - 1];
        }

        int         simpleregex::get_submatch_consumed(int id) const
        {
            return this->get_submatch_end(id) - this->get_submatch_start(id);
        }

        bool simpleregex::match(const std::string& str) // {{{1
        {
            return match(str.begin(), str.end());
        }

        bool simpleregex::match(const std::string& str, std::string& matched_sub) // {{{1
        {
            bool ret = match(str.begin(), str.end());
            if (ret) {
                matched_sub = str.substr(this->start_pos, this->consumed_cnt);
            }
            return ret;
        }

        bool simpleregex::match(const std::string& str, std::string& matched_sub, int& begin_pos) // {{{1
        {
            bool ret = this->match(str, matched_sub);
            if (ret) {
                begin_pos = this->start_pos;
            }
            return ret;
        }

        bool simpleregex::match(std::string::const_iterator str_beg, std::string::const_iterator str_end) // {{{1
        {
            // 备份匹配的起始位置
            this->to_match = std::string(str_beg, str_end);
            this->str_beg_bak = str_beg;
            this->start_pos = -1;
            this->consumed_cnt = 0;

            SSS_LOG_DEBUG("\"%s\" =~ simpleregex(\"%s\")\n",
                          sss::utlstr::sample_string(str_beg, str_end).c_str(),
                          this->reg_string.c_str());
            // 空的regex，能匹配所有的字符串
            if (match_tokens.empty()) {
                this->consumed_cnt = 0;
                return true;
            }

            // FIXME 2014-07-04 这里好像有问题！
            // START_MATCH 只出现在 match(,) 函数中！
            // 是不是应该在match_here 里面处理它？
            if (match_tokens[0].type == START_MATCH) {
                SSS_LOG_DEBUG("patch to match_here START_MATCH at [0]\n");
                this->start_pos = 0;
                return match_here(match_tokens.begin() + 1,
                                  match_tokens.end(),
                                  str_beg,
                                  str_end);
            }

            do {
                SSS_LOG_DEBUG("patch to match_here loop at [%d]\n",
                              std::distance(str_beg_bak, str_beg));

                // 每次循环开始，consumed_cnt 都应该清零；
                // 因为，就是因为没有匹配到，所以，才需要下一次循环；
                // 所以，consumed_cnt 肯定是 为0 的；
                this->consumed_cnt = 0;
                this->is_match_here_called = false; // 是否调用过 match_here 函数
                this->start_pos = std::distance(str_beg_bak, str_beg);

                if (sss::log::model(_MODEL_NAME_)) {
                    SSS_LOG_DEBUG("consumed_cnt = %d; start_pos = %d\n",
                                  this->consumed_cnt,
                                  this->start_pos);
                }

                if (match_here(match_tokens.begin(),
                               match_tokens.end(),
                               str_beg,
                               str_end))
                {
                    return true;
                }
            } while (++str_beg != str_end);
            return false;
        }

        bool simpleregex::match(std::string::const_iterator str_beg, std::string::const_iterator str_end, std::string& matched_sub) // {{{1
        {
            std::string::const_iterator match_beg;
            std::string::const_iterator match_end;

            bool ret = match(str_beg, str_end, match_beg, match_end);
            if (ret) {
                matched_sub = std::string(match_beg, match_end);
            }
            return ret;
        }

        // bool simpleregex::match(str_beg, str_end, match_beg, match_end) // {{{1
        bool simpleregex::match(std::string::const_iterator str_beg,
                                std::string::const_iterator str_end,
                                std::string::const_iterator& match_beg,
                                std::string::const_iterator& match_end)
        {
            bool ret = match(str_beg, str_end);
            if (ret) {
                match_beg = str_beg;
                std::advance(match_beg, this->start_pos);

                match_end = match_beg;
                std::advance(match_end, this->consumed_cnt);
            }
            return ret;
        }

        // bool simpleregex::match(str_beg, str_end, matched_sub, begin_pos) // {{{1
        bool simpleregex::match(std::string::const_iterator str_beg,
                                std::string::const_iterator str_end,
                                std::string& matched_sub,
                                int& begin_pos)
        {
            bool ret = match(str_beg, str_end, matched_sub);
            if (ret) {
                begin_pos = this->start_pos;
            }
            return ret;
        }

        // 替换
        struct subs_stem_t // {{{1
        {
            // NOTE 解析替换用字符串，将其拆分为替换的id或者字符串
            // TODO 以后可能支持内部脚本，以便进行复杂的表达式计算后替换。
            enum enum_subs_stem_t { ID = 0, STRING};

        private:
            enum_subs_stem_t type;
            int         subs_id;
            std::string str_val;

        public:
            explicit subs_stem_t(const std::string& s)
                : type(STRING), subs_id(0), str_val(s)
            {
            }

            explicit subs_stem_t(int id)
                : type(ID), subs_id(id)
            {
            }

        public:
            int get_id() const
            {
                return this->subs_id;
            }

            std::string get_str() const
            {
                return this->str_val;
            }

        public:
            static void parse_subs_str(const std::string& subs, std::vector<subs_stem_t>& out)
            {
                parse_subs_str(subs.begin(), subs.end(), out);
            }

            static void parse_subs_str(std::string::const_iterator subs_beg,
                                       std::string::const_iterator subs_end,
                                       std::vector<subs_stem_t>& out)
            {
                // NOTE，C++字符串，两个反斜杠，表示一个反斜杠！所以下面是6个反
                // 斜杠！
                sss::regex::simpleregex reg_subs("\\\\\\d\\>");

                // NOTE 需要特殊处理 "\\" 即可；
                std::string::const_iterator match_beg_it = subs_beg;
                std::string::const_iterator match_end_it = subs_end;

                std::string::const_iterator submatch_beg_it;
                std::string::const_iterator submatch_end_it;

                while (match_beg_it < match_end_it)
                {
                    if (reg_subs.match(match_beg_it, match_end_it,
                                       submatch_beg_it, submatch_end_it))
                    {
                        int id = sss::string_cast<int>(std::string(submatch_beg_it + 1, submatch_end_it));
                        if (match_beg_it != submatch_beg_it) {
                            std::string stem = std::string(match_beg_it, submatch_beg_it);
                            out.push_back(subs_stem_t(stem));
                        }
                        out.push_back(subs_stem_t(id));
                        match_beg_it = submatch_end_it;
                    }
                    else {
                        std::string stem = std::string(match_beg_it, match_end_it);
                        out.push_back(subs_stem_t(stem));
                        match_beg_it = match_end_it;
                    }
                }
            }

            static void print_subs_str(sss::regex::simpleregex& reg, const std::vector<subs_stem_t>& v_subs, std::ostream& oss)
            {
                for (size_t i = 0; i != v_subs.size(); ++i) {
                    const subs_stem_t& sub(v_subs[i]);
                    switch (sub.type)
                    {
                    case subs_stem_t::ID:
                        oss << reg.get_submatch(sub.get_id());

                    case subs_stem_t::STRING:
                        oss << sub.get_str();
                    }
                }
            }
        };

        std::string simpleregex::substitute(const std::string& s, const std::string& subs) // {{{1
        {
            return this->substitute(s.begin(), s.end(), subs.begin(), subs.end());
        }

        // bool simpleregex::substitute {{{1
        std::string simpleregex::substitute(std::string::const_iterator tar_beg,
                                            std::string::const_iterator tar_end,
                                            std::string::const_iterator subs_beg,
                                            std::string::const_iterator subs_end)
        {
            std::ostringstream oss;
            std::vector<subs_stem_t> v_subs;
            subs_stem_t::parse_subs_str(subs_beg, subs_end, v_subs);

            std::string::const_iterator match_beg_it = tar_beg;
            std::string::const_iterator match_end_it = tar_end;

            std::string::const_iterator submatch_beg_it;
            std::string::const_iterator submatch_end_it;

            while (match_beg_it < match_end_it)
            {
                if (this->match(match_beg_it, match_end_it,
                                submatch_beg_it, submatch_end_it))
                {
                    oss << std::string(match_beg_it, submatch_beg_it);
                    subs_stem_t::print_subs_str(*this, v_subs, oss);
                    match_beg_it = submatch_end_it;
                }
                else {
                    oss << std::string(match_beg_it, match_end_it);
                    match_beg_it = match_end_it;
                }
            }
            return oss.str();
        }

        int  simpleregex::sub_match_count() const
        {
            // 不算 "\\0"
            return left_anchors.size() - 1;
        }

        void simpleregex::print_match_info(std::ostream& out) // {{{1
        {
            out << "start_pos = " << start_pos
                << ", consumed_cnt = " << consumed_cnt << std::endl;
        }

        // bool simpleregex::match_here(tok_beg, tok_end, str_beg, str_end) {{{1
        bool simpleregex::match_here(match_tokens_t::const_iterator tok_beg,
                                     match_tokens_t::const_iterator tok_end,
                                     std::string::const_iterator str_beg,
                                     std::string::const_iterator str_end)
        {
            //if( regex[0]=='\0' )
            //    return 1;
            //if( regex[1]=='*' )
            //    return matchStar(regex[0], regex+2, text);
            //if( strcmp(regexp, "$") == 0 )
            //    return *text=='\0';
            //if( *text!='\0' && (regex[0]=='.' || regex[0]==*text))
            //    return matchHere(regex+1, text+1);
            //return 0;

            // 0 长的 regex，可以匹配任何字符串
            if (tok_beg == tok_end) {
                return true;
            }

            // NOTE 如何匹配分支？
            // 分支的话，需要知道定位上次的分割；
            // 形如：
            // \(part1\|part2\|part3\)
            // 另外，\|不应该出现在头部？如：
            // \(\|part1\|part3\)
            //
            // 其实，分支也简单；做一个循环就好；
            // 如何操作？
            // 我需要将配对区域内的 范围，用 "\|" 进行分割；然后，分段尝试进行配对；
            // 为此，我需要修改递归下降法对应的函数：
            // ――
            // 我需要一个新的函数，叫：
            // simpleregex::match_anchor 来代替，原本的：
            //> // 如果是"左锚点"
            //> if (tok_beg->type == ANCHOR_L_MATCH) {
            //>     ...
            //> }
            //> // 如果是"右锚点"
            //> if (tok_beg->type == ANCHOR_R_MATCH) {
            //>     ...
            //> }
            //
            // 形如：
            // if (tok_beg->type == ANCHOR_L_MATCH) {
            //     return match_anchor(tok_beg,
            //                         tok_end,
            //                         str_beg,
            //                         str_end);
            // }
            //
            // TODO 到底应该如何同时解决 范围(引用)与分支的问题？注意，用的是递归下降法
            // 焦点在于，这个循环的处理。我是用递归来模拟循环，还是用一个实际的循环呢？
            // 而且，还需要能复用 match_here。
            // 实际的循环的话，需要先分析同层的"分支"位置；比如，先创建一个分支index的数组；
            // 我觉得循环加复用match_here的话，需要让match_here自己完成后续的判
            // 断――跳出最内层的引用，再进行后续匹配。
            //
            // 递归模拟的话，就是在分支这里，做完后续匹配之后，进行判断，看是否
            // 能匹配。不匹配的话，就再往下一个分支；
            //
            // 就编程难度来说，还是"递归模拟"循环的方式简单一点。

            // 如果在最外层有分支：
            //   在match函数处，做一个调用match_here 的标记，然后在 match_here 这里，完成分支：
            if (this->left_anchor2branchs.find(-1) != this->left_anchor2branchs.end() &&
                !this->is_match_here_called)
            {
                this->is_match_here_called = true;
                // FIXME NOTE
                // 如果分支就开始匹配失败，也需要自动进入下一个分支！
                // 即，将被字符串都找完了，都找不到成功匹配
                match_tokens_t::const_iterator branch_beg = tok_beg;
                const std::vector<int>& branches = this->left_anchor2branchs[-1];
                std::vector<int>::const_iterator b_it = branches.begin();

                //std::cout << "[";
                //for (size_t i = 0; i != branches.size(); ++i) {
                //    SSS_LOG_EXPRESSION(sss::log::log_DEBUG, branches[i]);
                //}
                //std::cout << "]" << std::endl;

                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, branches.size());

                int offset = 0;

                do {
                    SSS_LOG_EXPRESSION(sss::log::log_DEBUG, offset);
                    bool ret = match_here(this->tok_beg_bak + offset,
                                          tok_end,
                                          str_beg,
                                          str_end);
                    if (ret) {
                        return ret;
                    }
                    offset = *b_it + 1;
                } while (b_it++ != branches.end());

                return false;
            }

            // 如果是"左锚点"
            if (tok_beg->type == ANCHOR_L_MATCH) {
                left_anchors[tok_beg->anchor_id] = std::distance(str_beg_bak,
                                                                 str_beg);
                // FIXME NOTE
                // 如果分支就开始匹配失败，也需要自动进入下一个分支！
                // 即，将被字符串都找完了，都找不到成功匹配

                match_tokens_t::const_iterator branch_beg = tok_beg + 1;
                const std::vector<int>& branches = this->get_branches(tok_beg);
                std::vector<int>::const_iterator b_it = branches.begin();

                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, branches.size());

                //std::cout << " branches : [ ";
                //for (size_t i = 0; i != branches.size(); ++i) {
                //    std::cout << branches[i] << " ";
                //}
                //std::cout << "]" << std::endl;

                int offset = std::distance(this->tok_beg_bak, tok_beg) + 1;

                do {
                    SSS_LOG_EXPRESSION(sss::log::log_DEBUG, offset);
                    bool ret = match_here(this->tok_beg_bak + offset,
                                          tok_end,
                                          str_beg,
                                          str_end);
                    if (ret) {
                        return ret;
                    }
                    offset = *b_it + 1;
                } while (b_it++ != branches.end());

                return false;
            }

            // 如果是"右锚点"
            if (tok_beg->type == ANCHOR_R_MATCH) {
                right_anchors[tok_beg->anchor_id] = std::distance(str_beg_bak,
                                                                  str_beg);
                return match_here(tok_beg + 1,
                                  tok_end,
                                  str_beg,
                                  str_end);
            }

            // 如果分支允许"" 空匹配；那么空匹配，加上一个"*"循环匹配，会怎么样？
            // ――死循环？
            // 遇到分支，说明之前的匹配，已经成功！
            // 因此，需要快速定位到最近的 ANCHOR_R_MATCH 节点，完成后续匹配；
            if (tok_beg->type == BRANCH_MATCH) {
                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, get_match_type_name(tok_beg->type));
                match_tokens_t::const_iterator nearest_r_anchor = get_nearest_r_anchor(tok_beg);

                if (nearest_r_anchor == this->match_tokens.end()) {
                    return true;
                }

                bool ret = match_here(nearest_r_anchor + 1,
                                      tok_end,
                                      str_beg,
                                      str_end);

                if (ret) {
                    // 能走到BRANCH_MATCH，说明之前匹配成功；此时，没有必要修改
                    //this->consumed_cnt
                    // 不过，貌似在失败的时候，需要扣除这些 "消耗" ...
                    // this->consumed_cnt += ret ? 1 : 0;
                }
                else {
                    // 如果后续匹配失败，则跳到下一个分支；
                    return match_here(tok_beg + 1,
                                      tok_end,
                                      str_beg,
                                      str_end);
                }
                return ret;
            }

            // 因为 *, {} 这种，允许0长匹配的存在
            // 因此，需要一个额外的数组或者函数，用来表示，当前节点，是否有对应的次数表示？
            // 即，在第一次处理次数动作的时候，就需要特殊处理，而不是等循环过后再做。
            // 如果允许0长匹配，那么，直接匹配 TIMES_MATCH 之后的节点；并记录下是否能匹配。
            // 其他情况，类似处理。
            // 总之，贪婪搜索，必须：
            // 1. 记录成功匹配；
            // 2. 每次匹配，需要走完整个正则表达式结构体；
            //
            // 至于非贪婪搜索，则是遇到第一次成功的匹配，就退出。
            //
            // 如何实现？
            //
            // 策略也简单：
            //  将 TIMES_MATCH 所引用的正则表达式，看作用整体，用 [begin, end)
            //  的方式，来定位，并进行比较。然后，将 TIMES_MATCH 之后的，作为后
            //  续串，再做一次匹配。
            //
            //  唯一需要注意的是，此处，不允许平移！必须马上得到匹配！――当然
            //  ，这是 match_here 函数能够保证的事情
            //
            //  这样的话，我必须额外，再定义一个数组，用来描述他是否被 TIMES_MATCH 节点控制着。
            //
            //  其他问题：
            //  1. 需要排除 多种 TIMES_MATCH 节点，串在一起的情况；
            //     从逻辑上，这种串接，是可以合并的。
            //
            //  2. 如何处理 分支 与 TIMES_MATCH ?
            //     我当前处理分支的模式，是记录了，分支的位置――依赖于串的开头，或者左锚点的位置；
            //     而对于 TIMES_MATCH 的处理，我又想在类似左锚点的位置，额外记
            //     录是否有对应的 TIMES_MATCH 节点；这就照成了冲突；
            //     理论上，我应该优先分析 TIMES_MATCH ，然后再处理分支；
            //
            //  3. 锚点嵌套如何处理？锚点应该记录最后一次匹配吗？
            //  aa aba abba abbba abbbba 
            //  /\(a\(b*\)a \)\+
            //  s/\(a\(b*\)a \)\+/\1\2/ge
            //  abbbba bbbb
            //  根据实验，vim内部嵌套，锚点，记录的是最后一次匹配的位置。
            if (tok_beg->type == TIMES_MATCH) {
            }

            if (tok_beg + 1 != tok_end) {
                if ((tok_beg + 1)->type == STAR_MATCH) {
                    // 至少需要消耗0个字符！
                    return match_star(*tok_beg,
                                      tok_beg + 2,
                                      tok_end,
                                      str_beg,
                                      str_end);
                }

                if ((tok_beg + 1)->type == PLUS_MATCH &&
                    str_beg != str_end && tok_beg->match(*str_beg))
                {
                    // 至少需要消耗一个str字符！
                    bool ret = match_star(*tok_beg,
                                          tok_beg + 2,
                                          tok_end,
                                          str_beg + 1,
                                          str_end);
                    if (ret) {
                        this->consumed_cnt++;
                    }
                    return ret;
                }
            }

            if (std::distance(tok_beg, tok_end) == 1
                && tok_beg->type == END_MATCH)
            {
                return str_beg == str_end;
            }

            // NOTE WORD_L_MATCH, WORD_R_MATCH
            if (tok_beg->type == WORD_L_MATCH) {
                return match_word_left(tok_beg,
                                       tok_end,
                                       str_beg,
                                       str_end);

            }
            // NOTE
            // WORD_R_MATCH 经常出现在正则表达式结尾；而此时，待匹配字符串，也
            // 常常恰好走到结尾
            if (tok_beg->type == WORD_R_MATCH) {
                return match_word_right(tok_beg,
                                        tok_end,
                                        str_beg,
                                        str_end);
            }

            // NOTE 引用匹配
            if (tok_beg->type == REFER_MATCH) {
                return match_refer(tok_beg,
                                   tok_end,
                                   str_beg,
                                   str_end);
            }

            if (str_beg != str_end) {
                // 还有未匹配的字符；并且当前字符匹配成功
                if (tok_beg->match(*str_beg)) {
                    bool ret = match_here(tok_beg + 1,
                                          tok_end,
                                          str_beg + 1,
                                          str_end);
                    this->consumed_cnt += ret ? 1 : 0;
                    return ret;
                }
            }

            return false;
        }

        // bool simpleregex::match_word_left(tok_beg, tok_end, str_beg, str_end) {{{1
        // prev is null or !isalnum(prev)
        //  and
        // isalnum(next)
        bool simpleregex::match_word_left(match_tokens_t::const_iterator tok_beg,
                                          match_tokens_t::const_iterator tok_end,
                                          std::string::const_iterator str_beg,
                                          std::string::const_iterator str_end)
        {
            if ((str_beg_bak == str_beg || ! isdigitword(*(str_beg - 1)))
                &&
                isdigitword(*str_beg))
            {
                return this->match_here(tok_beg + 1, tok_end, str_beg, str_end);
            }
            return false;
        }

        //bool simpleregex::match_word_right(tok_beg, tok_end, str_beg, str_end) {{{1
        // isalnum(prev)
        //   and
        // next is last or !isalnum(next)
        bool simpleregex::match_word_right(match_tokens_t::const_iterator tok_beg,
                                           match_tokens_t::const_iterator tok_end,
                                           std::string::const_iterator str_beg,
                                           std::string::const_iterator str_end)
        {
            //match_tokens_t::const_iterator tok_beg_bak = this->match_tokens.begin();
            SSS_LOG_DEBUG("(%d, ..., %c, %c)\n",
                          std::distance(tok_beg_bak, tok_beg),
                          (str_beg==str_end) ? '\0' : *str_beg,
                          '\0');
            bool ret = false;
            if ((str_beg_bak != str_beg && isdigitword(*(str_beg - 1)))
                &&
                (str_beg == str_end || ! isdigitword(*str_beg) ))
            {
                ret = this->match_here(tok_beg + 1, tok_end, str_beg, str_end);
            }

            SSS_LOG_DEBUG("ret = %d\n", ret);

            return ret;
        }


        //bool simpleregex::match_refer(tok_beg, tok_end, str_beg, str_end) {{{1
        // sss::is_begin_with( std::string(str_beg, str_end), pref_refer_substring )
        bool simpleregex::match_refer(match_tokens_t::const_iterator tok_beg,
                                      match_tokens_t::const_iterator tok_end,
                                      std::string::const_iterator str_beg,
                                      std::string::const_iterator str_end)
        {
            //match_tokens_t::const_iterator tok_beg_bak = this->match_tokens.begin();
            SSS_LOG_DEBUG("(%d, ..., %c, %c)\n",
                          std::distance(tok_beg_bak, tok_beg),
                          (str_beg==str_end) ? '\0' : *str_beg,
                          '\0');

            size_t refer_id = tok_beg->anchor_id;
            if (this->left_anchors.size() < refer_id) {
                throw std::invalid_argument("invalid refer_id.");
            }
            std::string refer_string = this->get_submatch(refer_id);

            bool ret = false;

            SSS_LOG_EXPRESSION(sss::log::log_DEBUG, std::string(str_beg, str_end));
            SSS_LOG_EXPRESSION(sss::log::log_DEBUG, refer_string);

            // FIXME 这里应该还需要考虑是否大小写敏感
            if (sss::is_begin_with(str_beg, str_end, refer_string.begin(), refer_string.end())) {
                ret = this->match_here(tok_beg + 1,
                                       tok_end,
                                       str_beg + this->get_submatch_consumed(refer_id),
                                       str_end);

                SSS_LOG_EXPRESSION(sss::log::log_DEBUG, ret);
                if (ret) {
                    this->consumed_cnt += this->get_submatch_consumed(refer_id);
                }
            }
            return ret;
        }

#if 0
        //bool simpleregex::match_anchor(tok_beg, tok_end, str_beg, str_end) {{{1
        // while (true) {
        //   if (prev == match && remaining == reg_out_side) {
        //     return true;
        //   }
        // }
        // return false;
        //
        bool simpleregex::match_anchor(match_tokens_t::const_iterator tok_beg,
                                       match_tokens_t::const_iterator tok_end,
                                       std::string::const_iterator str_beg,
                                       std::string::const_iterator str_end)
        {
            // 第一个 token 应该是 ANCHOR_L_MATCH; 然后到配对的 ANCHOR_R_MATCH
            // 的 token 结束；之后部分

            //// 如果是"左锚点"
            //if (tok_beg->type == ANCHOR_L_MATCH) {
            //    left_anchors[tok_beg->anchor_id] = std::distance(str_beg_bak,
            //                                                     str_beg);
            //    return match_here(tok_beg + 1,
            //                      tok_end,
            //                      str_beg,
            //                      str_end);
            //}
            //// 如果是"右锚点"
            //if (tok_beg->type == ANCHOR_R_MATCH) {
            //    right_anchors[tok_beg->anchor_id] = std::distance(str_beg_bak,
            //                                                      str_beg);
            //    return match_here(tok_beg + 1,
            //                      tok_end,
            //                      str_beg,
            //                      str_end);
            //}

            // 这个新函数，目的是将原本分开处理左右锚点，合并在一起。此时，如何完成匹配？
            // 矛盾在于，原本是递归下降，出入锚点区域的时候，会分别记录匹配锚点
            // 位置，然后递归过程，完成后面的匹配。
            //
            // 而我的新方案，妄想在一个过程中，对锚点内部进行匹配，甚至支持分支
            // ――即，记录分支情况下的"选路情况"。

            // 当然，如果沿用之前的前后锚点分开的办法，也应该可以处理分支――进
            // 入循环后，记录了一开始匹配的位置！

            // 我觉得还是回到原来的方案：我不可能再去写一堆的 switch case，所以，我必须重用 match_here
            //
            // 不过，为了处理分支，我可能需要额外存储一些信息，比如：当前引用深
            // 度、当前引用，对应的token序列号。
            //
        }

#endif
        // bool simpleregex::match_star(tok, tok_beg, tok_end, str_beg, str_end) {{{1
        // TODO FIXME 如何支持 范围的 \(...\)* 匹配？
        bool simpleregex::match_star(match_token tok,
                                     match_tokens_t::const_iterator tok_beg,
                                     match_tokens_t::const_iterator tok_end,
                                     std::string::const_iterator str_beg,
                                     std::string::const_iterator str_end)
        {

            //do{ // a * matches zero or more instances
            //    if( matchHere(regex, text))
            //        return 1;
            //}while( *text!='\0' && ( *text++==c || c=='.' ));
            //return 0;

            // NOTE 如果是贪婪搜索的话，就需要记住最后（远）一次正确匹配。
            std::string::const_iterator str_beg_bak = str_beg;
            do {
                if (match_here(tok_beg, tok_end,
                               str_beg, str_end))
                {
                    this->consumed_cnt += std::distance(str_beg_bak, str_beg);
                    return true;
                }
            } while ( str_beg != str_end && tok.match(*str_beg++) );
            return false;
        }

        const std::vector<int>& simpleregex::get_branches(simpleregex::match_tokens_t::const_iterator tok_l_anchor)
        {
            //simpleregex::match_tokens_t::const_iterator tok_beg_bak
            //    = this->match_tokens.begin();

            SSS_LOG_EXPRESSION(sss::log::log_DEBUG, std::distance(tok_beg_bak, tok_l_anchor));
            return left_anchor2branchs[std::distance(tok_beg_bak, tok_l_anchor)];
        }

        //match_tokens_t::const_iterator simpleregex::get_nearest_r_anchor(match_tokens_t::const_iterator tok_branch) {{{1
        simpleregex::match_tokens_t::const_iterator simpleregex::get_nearest_r_anchor(simpleregex::match_tokens_t::const_iterator tok_branch)
        {
            simpleregex::match_tokens_t::const_iterator r_anchor = this->match_tokens.end();
            if (tok_branch != this->match_tokens.end() && tok_branch->type == BRANCH_MATCH) {
                int branch_pos = std::distance(simpleregex::match_tokens_t::const_iterator(this->match_tokens.begin()), tok_branch);
                int r_anchor_pos = this->branch2right_anchor[branch_pos];
                if (r_anchor_pos == -1) {
                    return this->match_tokens.end();
                }
                r_anchor = this->match_tokens.begin();
                std::advance(r_anchor, r_anchor_pos);
            }
            return r_anchor;
        }

        // int simpleregex::consume_times_token(regs_here, regs_end, & p_greed, & t_min, & t_max) {{{1
        // NOTE 与以前处理 BDE 类似，我需要若干函数，能进行字符串解析：预看下一个字符、几个字符，分支
        // 等操作的函数。
        // 见：d:\program\msys\extra\sss\include\sss\BDEAlias.cpp|291
        // 为了不用写 if 可以用抛出异常的方式：
        //
        // start_with_require(regs_here, regs_end, '{', "");
        int simpleregex::consume_times_token(std::string::const_iterator regs_here,
                                             std::string::const_iterator regs_end,
                                             bool & greed,
                                             int & t_min,
                                             int & t_max)
        {
            std::string::const_iterator regs_here_bak = regs_here;
            // 从 { 开始 到 } 结束；
            // {} 至少2个字符
            int ret = 0;

            // '{'
            if (*regs_here++ != '{') {
                return ret;
            }

            // bool greed
            greed = true;
            if (*regs_here == '-') {
                greed = false;
                regs_here++;
            }

            // times min default = 0
            t_min = 0;
            bool has_t_min = false;
            if (std::isdigit(*regs_here)) {
                has_t_min = true;
                t_min = 0;
                do  {
                    t_min += 10 * t_min + (*regs_here - '0');
                } while (regs_here + 1 != regs_end && std::isdigit(*++regs_here));
            }

            bool has_common = false;
            // common
            if (*regs_here == ',') {
                regs_here++;
                has_common = true;
            }

            // times max default = -1
            t_max = has_common || !has_t_min ? -1 : t_min;
            if (std::isdigit(*regs_here)) {
                t_max = 0;
                //std::cout << t_max << " ";
                do  {
                    t_max *= 10;
                    t_max += (*regs_here - '0');
                    std::cout << t_max << "(" << (*regs_here - '0') << ") ";
                } while (regs_here + 1 != regs_end && std::isdigit(*++regs_here));
                //std::cout << std::endl;
            }

            // '}'
            if (*regs_here++ != '}') {
                return ret;
            }

            ret = std::distance(regs_here_bak, regs_here);

            // NOTE vim中，允许 {10,5}这种存在！
            if (t_max >= 0 && t_max < t_min) {
                std::swap(t_max, t_min);
            }

            return ret;
        }

        // TODO 重置状态值，以迎接下一次匹配；
        void simpleregex::reset()
        {
            // TODO
        }
    } // end-of namespace regex
}// end-of namespace sss

