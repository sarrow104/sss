多结果获取-论文

//"封装DB-Library函数实现VC对SQL"
//!Computer Applications
//!2000  Vol.20  No.2  P.38-40
//!Server的快速访问
//!汪闽  苏国中
//     摘  要：利用VC面向对象技术将DB-Library API函数封装成类，从而屏蔽了直接调用
// 的许多复杂概念，为其使用提供了简易接口。本实现对利用DB-Library进行SQL Server客
// 户端应用的开发工作具有重要的参考价值。
//     关键词：DB-Library；SQL server；面向对象
//     中图文章编号：1001-9081(2000)02-0038-03

ENCAPSULATE
THE FUNCTIONS OF DB＿LIBRARY TO
IMPLEMENT QUICK ACCESS OF VC TO SQL SERVER
WANG Min

（The Earth Science Department of Zhejiang University, Zhejiang.Hangzhou 310028 China）
SU Guo-zhong

（The Foundational Research Center of Geographic Information System of Haian Province,
Hainan.Haikou 570203 China）

    Abstract: To

shield many complex concepts produced by calling them directly and give simply interface
for using,the author encapsulates the functions of DB-Library to form a class
by using the Object-oriented technology of VC.This implement gives important reference
values to the development work of the client part for SQL Server using DB-Library.

    Key words: DB-Library;SQL
Server;Object-oriented technology

//!1  DB-library的有关概念和特点
//     DB-Library或DB-LIB，对C和VB而言，都是一个API，它允许用户直接处理SQL
// Server。API提供给用户不同的工具，用户用它们来发送查询到SQL Server和从SQL
// Server接受信息。事实上，DB-Library是如ODBC，DMO，DAO和RDO这些更高级的API的底
// 层公共接口，而它们在不同程度上屏蔽了直接调用DB-Library的复杂的接口工作。然而
// ，也正是由于DB-LIB较之ODBC等数据库引擎而言更加“底层”，利用它实现客户──服
// 务器模式的应用程序的前后台通信任务具有程序代码短小、灵活快捷的特点。作者在以
// VC、DB-LIB为工具进行SQL Server客户端应用开发的工作中，利用VC的面向对象技术，
// 将DB-Library for C的部分函数进行了封装，形成一个CDblink类，以类的成员函数的形
// 式向开发者提供数据库访问的简易接口，从而较好地解决了使用难度和访问速度这一对
// 矛盾。

//!2  DB-Library For C函数的封装
    CDblink类需实现以下主要功能：
    .登录SQL Server，开辟结果缓冲区；
    .发送SQL语句，返回结果记录集到结果缓冲区；
    .取结果记录集的任意记录；
    .关闭和SQL Server的连接。
//!2.1  登录SQL Server，开辟结果缓冲区
//     DB-Library函数通过DBPROCESS结构实现和SQL Server的通信。DBPROCESS结构作为应
// 用程序和SQL Server的连接中介，在其中记录了该应用某次访问的登录用户名、口令、服
// 务器名、应用名称等重要信息，绝大多数的DB-Library函数需要以该结构作为第一个调用
// 参量。一个应用程序可以以多个DBPROCESS同时对SQL Server进行访问，相互之间不受干
// 扰。对于DB-Library来说，登录SQL Server，就是用正确的登录信息填写DBPROCESS结构
// 。为满足能够任意访问查询结果集中某一记录的需要，logtosvr()成员函数在实现上述功
// 能的同时，也确定了结果缓冲区的大小（如不开辟结果缓冲区，我们只能每次从服务器上
// 读取一行数据，处理完必之后再读入下一行，上一行数据被覆盖，造成使用不便；开辟了
// 一定大小的结果缓冲区后，就可一次性读入大小等于缓冲区大小的结果集存入其中，用
// dbgetrow()函数任意定位读取记录）。程序代码如下（注：以下所用的DB-library函数均
// 以′db′打头）：

//以合法的用户身份登陆SQL Server
bool CDblink::Logtosvr()
{
  /*获取 login 结构,该结构作为dbopen()(打开数据库，创建一个新的DBPROECSS结构)的参量.*/
  PLOGINREC login = dblogin ();
  /*用用户输入的登录信息:登录用户名(loginfo.User)、口令(loginfo.PassWord)、登录应用名
  （loginfo.AppName）填充login结构*/
  DBSETLUSER (login, loginfo.User);
  DBSETLPWD (login, loginfo.PassWord);
  DBSETLAPP (login, loginfo.AppName);

  //设置登录延时
  dbsetlogintime (2);
  // 登录数据库，得到dbproc（一个指向新建DBPROCESS结构的指针）
  dbproc = dbopen(login, loginfo.Server);
  if(!dbproc)
  {
    SendMsg("登录SQLSERVER失败");
    return false;
  }

  //把结果缓冲区设为MaxLineNum行
  char buflen[10];
  wsprintf(buflen,"%d",MaxLineNum+1);
  // 设置链接属性，为“缓冲”模式；最多缓冲MaxLineNum行――所需要的内存控件，由
  // FreeTDS库自己解决。客户端程序，在其生存区内，可以自由使用后续如dbdata返回的
  // 指针指向的空间。
  // 如果缓冲区被充满了，需要调用dbclrbuf()
  // 是否为缓冲模式，是与进程相关的；客户程序，可以随时修改本设定。
  dbsetopt(dbproc, DBBUFFER, buflen);

  return true;
}

//!2.2  发送SQL语句，返回结果集

//     登录SQL Server之后，就可以向SQL Server发送SQL语句，包括select
// ,insert,update,delete等。DB-Library也允许用户输入以‘Exec’打头的SQL语句，执行
// 存于服务器上的一个存储过程，这样就极大地扩展了DB-Library的功能。DB-Library将用
// 户的SQL语句存入命令缓冲区，用户一次可发送数个SQL语句，称为一个“命令批次”（
// command batch）。缺省状态下，用户在执行了一个命令批次后DB-LIB将清除命令缓冲区
// 中的已有内容，并提供函数供用户返回命令批次中每个查询的结果集。由于在实际应用中
// 有时我们并不知道本次查询将有几个SQL语句将返回结果集（例如在执行一个存储过程时
// ），为方便起见，作者设计的ExecSQL()成员函数只取最后一个查询的结果集（这种方法
// 能够满足绝大多数情况下的查询需求），实现的方法就是遍历每一个SQL语句的结果集，
// 将结果取出到结果缓冲直到最后一个，由于取下一个SQL语句的结果集都将清除上一个的
// 结果集，结果缓冲区中最终保留的将是最后一个SQL语句的结果集，程序如下：

/*向服务器发送命令，lpszStatament参量是用户输入的SQL语句。*/
bool CDblink::ExecSQL(LPCTSTR lpszStatement)
{
  //查询返回值
  RETCODE result_code,retcode;
  //清除命令缓冲区
  dbfreebuf (dbproc);
  //向dbproc添加SQL串，用户一次可添加多个查询语句
  if(dbcmd(dbproc, lpszStatement) != SUCCEED)
    return false;
    //DB-LIB执行该SQL语句
  if(dbsqlexec(dbproc) != SUCCEED)
    return false;
  //从服务器取数据到结果缓冲区
  m_Rows = 0;
  loopID = FALSE;
  /*遍历每个SQL语句的结果集直到最后一个（NO_MORE_RESULTS代表已无结果集可取）*/
  while((result_code = dbresults(dbproc)) != NO_MORE_RESULTS)
  {
    //取某个结果集操作成功
    if (result_code == SUCCEED)
    {
      m_Rows = 0;                                          //记录某一结果集的行数
      //遍历结果集中的每一行
      while ((retcode = dbnextrow(dbproc))!= NO_MORE_ROWS)
      {
        m_Rows++;
        /* 省略MaxLineNum行以上的行（MaxLineNum代表缓冲区的大小），如果缓冲区已填
         * 满，DB-LIB将不再读取该结果集的下一行，因此需清除缓冲区的一行，读入下一
         * 行，直到读完。*/
        if(m_Rows > MaxLineNum)
        {
          dbclrbuf(dbproc, 1);	// Clear n rows from the row buffer.
	                        // （n: number of rows to remove, >= 0.）
	  m_Rows--;
	}
      }
    }
    else break;
  }
  /*读入当前缓冲区的列数（也就是当前查询表的列数），m_Cols是CDblink类的成员*/
  m_Cols = dbnumcols(dbproc);
  return true;
}
//! 2.3  取结果缓冲区的任意记录
//     当结果集从服务器取到结果缓冲区之后，我们就可以取结果缓冲区的任意一条记录
// 。为此，我们专门定义了一个RESULT结构，为CDblink添加成员变量RESULT
// result[100]; 用来存储返回记录的每列的数据指针和列的数据长度（result数组开100
// 大小对绝大多数表已足够）。这样在应用时就可通过强制数据类型转换，将其转化为VC
// 能够接受的数据类型。RESULT结构如下：
typedef struct
{
    LPBYTE p; //列数据指针
    int n; //列数据长度
} RESULT;


//  程序实现如下：

//取第num行数据
RESULT *CDblink::GetResultRow(int num)
{
  //如果dbproc非法，拒绝执行该操作
  if(!dbproc) {execID = false;return NULL;}
  //如果索取行<0行或超出返回的结果集的行总数，拒绝执行该操作。
  if(num<0 || num > m_Rows) return NULL;
    //返回的是正常行（非统计行（compute row））
  if(dbgetrow(dbproc, num) == REG_ROW)
  {
    //将该行的每一列的数据指针、长度信息存入对应的result数组的对应项中。
    for(int i=0; i< m_Cols ; i++)
    {
      //第i+1列的数据指针
      result[i].p = dbdata(dbproc, i+1);
      //第i+1列的数据的长度
      result[i].n = dbdatlen(dbproc, i+1);
    }
    return result;
  }
  else
  {
    return NULL;
  }
}

// 2.4  关闭和SQL Server的连接
CDblink::~CDblink()
{
  //关闭与SQL Server的连接。
  dbclose(dbproc);
  dbwinexit();
}

//!2.5  实例
//    利用CDblink类，我们可以方便地实现对SQL Server的访问。举一应用实例：
//    (1) CDblink* SqlDB=new CDblink;
//    (2) SqlDB->ExecSQL("select * from ServerName.dbo.TableName ");
//    (3) RESULT* res=SqlDB->GetResultRow(1);
//    (4) 读取res中的每一列，进行强制类型转换。如如第一列在SQL
//Server为整型，长度为4个字节，则对应VC的数据类型也为整型，转换方式为int
//VC_var = *(int*)res[1].p，余者类推。
//    (5) delete SqlDB;

//!3  总结
//     CDblink类实现了对DB-LIB部分重要函数的封装，将其和服务器端存储过程协调使用
// ，能够满足绝大多数情况下客户端对服务器端的访问需求，且使用简单灵活，方便快捷，
// 优点是明显的。然而，对于其中如结果缓冲区大小限制、只能对正常行进行操作等不足之
// 处，则需在今后进一步的科研实践工作中加以改进。
//
// 作者简介：江闽  硕士研究生，主要研究方向：GIS与遥感、GIS新技术集成；
//           苏国中  高级工程师，主要研究方向：GIS软件开发。
// 作者单位：汪闽（浙江大学西溪校区资源与海洋工程系  浙江.杭州310028）
//           苏国中（海南省基础地理信息系统中心  海南.海口570203）
// 参考文献
// [1]  SQL Server 6.5开发指南[M],第二版.
// 北京：清华大学出版社,1998.
// [2]  SQL Server 6.5开发使用手册[M].北京：机械工业出版社,1996.
// [3]   Microsoft公司.Programming DB-Library for C Help[M]，1995.
