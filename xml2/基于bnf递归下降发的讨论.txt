* 基于bnf递归下降发的讨论.txt

date:2015-07-18

======================================================================

函数众多，环环相扣。

如何记录出错的位置？

解析的时候，缺少“预读”，导致路径是基于“尝试”的寻路方式。每种路径，由于是N多
函数嵌套组成的，无法一下子看出这些路径之间，开头，有没有重复的部分、重复了多少；

导致的问题就是，可能要N多步骤之后，才发现某种选路是不通的；于是得从头走；还得再
函数调用……

于是重复了。

我手写的方式，虽然可能会遗漏一些情况，甚至与标准不一致的地方，但是，我可以事先找
到重复的部分，直接在分支位置进行选路。

上述问题，用例子表示就是：

<node a1="v1" a2="v2" ... an="vn" />

如何知道上述节点，是一个 EmptyElemTag 还是一个 STag 呢？

在前面的 '<' Name ( S Att ) * 部分，是看不出来的；得解析到 '/>'。

----------------------------------------------------------------------

记录走的最远的路径，以及尾端的出错信息；

----------------------------------------------------------------------

考虑这种情况，分支 x ::= ( a | b | c )*

像上面这种，本质上是分支外面套循环的结构；关键在于，允许空匹配！即，对于产生式
x来说，最远处的错误，可能offset大于0；而其实呢，它自己是匹配成功的！

即，这个产生式，允许不消耗字符！

那么，从逻辑上来说，这些子分支，所产生的错误消息，都应当取消；就是说，在处理某一
个产生式的时候，应当对内部分支选择的错误信息，做统计，也采用rewind，commit的方式
，来生效、取消这些错误消息；

----------------------------------------------------------------------

我总觉得，我选择的这条路，好烦！还是看看tiny-xml,rapidxml源代码吧？

----------------------------------------------------------------------

语言如此多，bnf又常用，那么 作为编译器的编译器，ya、b 等工具，是如何工作的呢？

肯定不是用人工找出相同部分。

匹配原理 那本书，提到有 memory 的方式；即，先将判断号的Token记下来，那么重新选路
的时候，就不用从原始字节流里面再去解析Token，只需要从已经解析好的池子里面，将这
部分挑选出来即可；

也就是说，虽然还是回溯，但是不用深入到N层以内的函数；

那么，细化一下，我这里，在没有采用token序列化的情况下，又应当如何进行memory加速
呢？

----------------------------------------------------------------------

同样，还有数据结构的构造问题；

之前，选路的回退，是通过记录选路之前的开始迭代器指向位置，当遇到错误发生的时候，
就退回记录点的办法——因为需要记录的，其实就一个数据，所以相当简单易懂；

而数据结构的建立，就是一个麻烦了。

因为一开始，没有将数据进行序列化，当回退的时候，可能已经建立起一个对象，并与已有
部分关联起来；

此时，如果发现此路不通，就需要将动作回滚——不然，就得复制整个xml树，通过销毁或
者替换的方式来处理。

----------------------------------------------------------------------

怎么办，如何构造？将如何构造的方法、对象，传入or_throw函数？还有一个“消耗”的问
题；因为，当前选路可能在最后失败——甚至，当前的选路，只是上层的一部分。在上层失
败了，意味着，现在的选路，发生的这些构造，也是不正确的。那么，吃进去的，再吐出来
？

还有，可否设定一个可接受的“函数抽取”列表？——此时，是否有这种情况，某深处用到
的函数，与当前层，用到同一个函数，两者冲突了？保留哪一个？

或者，采用“首位制”；上层，可能会覆盖下层的；一个完全覆盖，比如，都开始于同一个
位置，但是消耗字节数不一样；这就意味着一个完全覆盖，此时，可以忽略小的部分？

如此，可以解决分支问题；因为，一个选路，由若干小的部分组层，此时，可以考虑用数据
结构表示；

一个完全的拼凑，可以用树形结构表示；同一个级别，用数组表示先后、拼接关系；位于子
节点，表示包含关系——不允许重叠——这与递归下降，消耗匹配的算法不符；如果出现这
种情况，一定是出错了！

** 选路与出错 错误处理

xml文件，不是随意性的文件。它是有一定的行文规范的；我上面有一些讨论了，但貌似没
有提到这个问题：

虽然有些parse_xxxx动作，内部是有分支的；但是，一般进入了两三个判断，再出错的话，
一般是真遇到解析问题了——xml本身有错误。

像 <!-- , <node attlist ... 这种，在前面 字符的判断，就可以拦截、区分开来。但是
，像 <node> 与 <node/>，至少就要分析到第三个节点才能知道错误与否，然后，重新选路
。

并且，走到这里，xml只能有上述的解析情况发生，不可能再把整个部分，理解为注释什么
的。

此时，若抛出异常，那就是真异常，而不是正常的选路回退！——当然，如果真可以有其他
选路，那么，可以肯定，还会发生错误，并且走不到这么远！（此说法，不敢肯定）

完全由人工去分析判断，这到底是是可以退回再选路，还是直接跑错，那整个工作量，就巨
大了，而且容易出错。

我觉得，需要记录一个最远错误位置——当然，还有错误信息；

——我感觉修改的工作量，也很大，因为，我很多地方用的是 if + && || 的方式。根本没
有马上throw……

----------------------------------------------------------------------

当然，选路过程中，错误、成功部分，可以记录一下；下一次选路的时候，可以进行参考；

首先，整个mem对象，是与parse_document一体的；所以，它应该是xml_parse的成员；

另外，它与具体函数关系不大，基本每个函数，都可以纳入上述范围；

只不过，它是基于动作的；

在进入 parse_xxxx 函数的时候，它需要马上询问mem，看是否在当前位置，调用过本函数
；如果没有查到，那么继续；

如果查到，那么，将缓存的信息，写入 Rewinder_t r对象（或者直接更改xml_parse对象）
，然后返回即可；

如果没有缓存信息，那么继续往下走；

在return 前，还有 catch 位置进行改写；

不过，我确实需要进行修改了！

try {} 不应该包括 Rewinder_t 等对象！即：

try {
   Rewinder_t r(s_beg);
}
catch () {
   ...
   return ......;
}

修改为：

Rewinder_t r(s_beg);
try {
}
catch () {
   ...
   r.rollback();
}

return ...;

还有一个最大的问题，这个memory动作，只适于叶子级别的 parse_xxxx！类似 <tag_name
attlist ..> 这种级别的 memory 是难于记忆，并且没有记录的效果的！

因为，记忆路径，是方便回溯重新选路的时候，可以跳过已经走过的路；那么，实际操作中
，若发现当前选路的，已经被走过——不可能是根部的选路，也不可能是原样原位置的自己
——这就是（做递归，死循环了），那么，根据记录，它已经被成功验证为某某结构，那么
将消耗情况，原样拷贝过来即可；如果其本身是多个部分的组合（就是说，有子树），此时
，我应当从记录下来的子树，拷贝过来给它！

我可以在~Helper()函数做手脚——让xp额外维护一个已经删除的节点树，然后，把本应该
在成功树，被remove部分的子树，整体挪过去——以函数id、起始位置偏移作为键值，来获
取它；

以 <tag_name attlist> 的解析为例；
bnf生成式是：

element ::= EmptyElemTag | STag content ETag

其中，路径 EmptyElemTag 和 路径 STag 的开头部分一致，只有 结束符号 '/>' 和 '>'
不一致；

于是，我的实际情况就是，需要回溯：

Name (S attribute) *

这部分数据；

我简化一下 Helper 的操作流程：

new_enter EmptyElemTag
 push '<'
 push Name
 push S
 push attribute0
 ...
 push S
 push attributeN

del_seg EmptyElemTag

new_enter STag
 push '<'
 push Name
 push S
 push attribute0
 ...
 push S
 push attributeN
 push '>'
new_exit STag
...

----------------------------------------------------------------------

不过，说实在的，就算保留这个seg子树结构，也没什么用——因为真正需要保留的，不是
这个结构。如果只是bnf的话，只不过可以作为一个xml文法的基本校验——此时，只需要记
录成功与否，还有匹配的范围，不用树形结构。

策略：

	在parse_xxxx 结尾；如果当次无效；则对seg进行检测；
		如果没有子节点，那么删除节点，并mem为死路；
		如果有子节点，则依次分离子节点——或者用一个空的seg代替——这样
		，修改func_id，然后整个转移，挂在某map树下面；

	对于 attributes ，可以额外挂一个树形子树，这样如果树形特别多，就可以节省
	parent(new_parent)操作的次数；

	而在 parse_xxxx开头，还是以 EmptyElemTag -> STag 为例。在EmptyElemTag 解
	析式内部，结束的时候，发现，无法匹配'/>'，而是遇到一个 '>'；原本的动作是
	，将当前seg，从seg树中删除；现在，应当在mem中，标记从开始位置，无法匹配
	parse_EmptyElemTag；同时，将Name,Attributes挂在成功的mem下面。此mem有一
	个特点，都应该不是在seg树上的节点！因为，这部分都是成功的！

	接着，parse_EmptyElemTag 函数返回；parse_element 函数不得已，进入第二个
	分支；

	解析'<'之后，开始进入 parse_Name。这个函数，发现mem中，以该位置，有访问
	过本函数。并且是成功的，就把这个seg节点，抓过来，同时，从“移除”mem树中
	，删除该节点；

	接着，遇到 parse_Attributes 函数，同样发现，已经有通过的访问记录；区别在
	于，这是一整棵树；于是，通过根节点，转移过来。

	最后，处理'>'成功；STag 走完；

	当然，如果遇到 parse_content 或者 parse_Etag 出错，又怎么办？——此时，
	肯定是xml文本的问题，无法重新选路解决——但是，我并不像把这个，硬编码到
	我的代码里面——虽然，我的seg解析树，本质上，已经是硬编码了——某个函数
	，是否纳入生成系统，我都是手动编写代码，来解决的。

	当然，可以给每个parse_xxxx函数，做一个快照，用数组的形式，存放是否进入
	Helper。

	这样的话，开关、也相对容易些。

	另外，发生解析错误，如果有抛出异常，可以把异常，加上位置信息，错误描述，
	和 函数名-调用位置 绑定在一起，并将最后一个位置，返回给用户！

	这就完成了错误处理了！

	没有硬编码，完全程序自动完成！

	——当然，就bnf生成式来说，写为

	element ::= STag content ETag | EmptyElemTag

	更好。毕竟STag ... 组合，比 EmptyElemTag 更多。

----------------------------------------------------------------------

可以利用 handle的方式！构建的时候使用handle来包裹；只有当最后一步完成的时候，才
转移管理权限；

当然，还有一种办法，就是，对于某函数，假设各个分支所活取到的数据，都可以用一种数
据结构来保存——这个过程中，可以对信息，进行切换；

当然，如果所有分支都失败，那么，还是得清空数据；

----------------------------------------------------------------------

** xml树需要用到的<>结构表

        Comment    ::=   '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
        PI         ::=   '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'

        CDSect     ::=   CDStart CData CDEnd
        CDStart    ::=   '<![CDATA['
        CData      ::=   (Char* - (Char* ']]>' Char*))
        CDEnd      ::=   ']]>'

        XMLDecl    ::=   '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
        TextDecl   ::=   '<?xml' VersionInfo? EncodingDecl S? '?>'

        doctypedecl   ::=  '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'

        STag       ::=          '<' Name (S Attribute)* S? '>'
        Attribute          ::=          Name Eq AttValue

        ETag       ::=          '</' Name S? '>'

        EmptyElemTag       ::=          '<' Name (S Attribute)* S? '/>'

----------------------------------------------------------------------

** DTD解析需要处理的标签
        elementdecl        ::=          '<!ELEMENT' S Name S contentspec S? '>'

        AttlistDecl   ::=       '<!ATTLIST' S Name AttDef* S? '>'

        includeSect        ::=          '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'
        extSubsetDecl      ::=          ( markupdecl | conditionalSect | DeclSep)*

// ignoreSect 有循环使用到 '<![', ']]>' 标记
        ignoreSect         ::=          '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'
        ignoreSectContents         ::=          Ignore ('<![' ignoreSectContents ']]>' Ignore)*


        GEDecl     ::=   '<!ENTITY' S Name S EntityDef S? '>'
        PEDecl     ::=   '<!ENTITY' S '%' S Name S PEDef S? '>'

        NotationDecl       ::=          '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'

** 注意

xml与dtd解析，在 intSubset 部分，有交互；

我的建议是，对于xml的解析，<!DOCTYPE 部分，[intSubset] 这里，可以原样按文字保留
。

即，暂时只需要对“根节点名”进行校验；即，intSubset 这部分，不管是否构建DTD解析
结构，xml原文的这块信息，都原封不动，保留。

然后，我只需要看一下，我的xml类族，是否能完整表示 上述 xml相关节点信息即可；以便
构建完整的解析树；

----------------------------------------------------------------------

date:2015-07-26

bnf构建 xml 树，如

parse_element 在最后，有数据（r.count()），那么可以构建xml节点。

关键在于content部分，如何保存。

seg能构建成功，是因为Helper在构造函数（parse_xxxx 开头），就插入节点——虽然不完
整

STag ETag等结构，不会有二义性

从使用上看，1. 作为数据源。此时，只需要考虑element树（含attlist）。

2. 输出时，seg树即可。——相当于原样输出。

作为数据源的使用方式，还是有问题的。父子节点，有限制性，那么可以看做对象数组。如
果是any，则没有规律（总之，带有times标记的情况，并且，允许多种节点，都有这种情况
。）

用的话，真的只关心数据检索；即，找出满足条件的数据集合——若不是集合，也是一个可
以枚举的指针，方便上下移动；也不会关心空白、注释等东西。

----------------------------------------------------------------------

** bnf element attribute name 查重实现 -- OK

while 循环 记录 seg 开始位置，要么 再来一个 xp->last_seg用来记录上次的seg指针；
其下一个兄弟，就能枚举attlist了。stl::set
